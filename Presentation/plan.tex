\documentclass[9pt]{book}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}
\usepackage{tikz}
\usepackage{syntax}
\usepackage{relsize,exscale}
\usepackage{stmaryrd}
\usepackage{MnSymbol}

\newcommand{\verifast}{VeriFast}
\newcommand\sepimp{\mathrel{-\mkern-6mu*}}
\newcommand\phibra{\llbracket\phi\rrbracket}
\newcommand\psibra{\llbracket\psi\rrbracket}
\newcommand\smallsum{\mathsmaller\sum}

\lstset{language={C}}
\lstset{alsoletter={&},morekeywords={predicate,array,true,false,lemma,&*&}}

\newtheorem{definition}{D\'efinition}[section]

\setcounter{tocdepth}{2}

\begin{document}
\addcontentsline{toc}{chapter}{Introduction}
\chapter*{Introduction}
	\section*{Objectif du TRE}
		\subsection*{Int\'er\^et de prouver des programmes}
		Aujourd'hui, les programmes informatiques sont de plus en plus pr\'esents dans notre quotidien et ont certaines fois notre vie entre leurs lignes. En effet, si un bug informatique emp\^eche le m\'etro de s'arr\^eter ou fait exploser une fus\'ee, il risque d'y avoir des pertes humaines. \par
		Malheureusement, v\'erifier qu'un programme est correct est ind\'ecidable. Du coup, la m\'ethode la plus courante est de tester un programme dans diff\'erents environnements. Cependant, on ne peut pas tester le nombre infini de vols possibles d'une fus\'ee. Les m\'ethodes de test permettent de conna\^itre le comportement r\'eel du programme dans un environnement pr\'ecis; \`a l'inverse, d'autres m\'ethodes utilisent un mod\`ele de l'ex\'ecution du programme pour d\'eterminer une approximation du comportement du programme dans de nombreux environnements. M\^eme si le r\'esultat est une approximation, cette m\'ethode d\'etectera si le programme se comporte correctement. Par contre, elle peut indiquer qu'un programme n'est pas correct alors qu'il l'est. Mais ceci n'apporte aucun pr\'ejudice \`a la s\'ecurit\'e.
\par Les m\'ethodes d\'eductives qui vont prouver qu'un programme suit sa sp\'ecification utilise la logique de Hoare.\\
		Cette logique se base sur le triplet de Hoare muni d'axiomes et r\`egles pour toutes les instructions de base d'un langage imp\'eratif. Le triplet est constitu\'e d'une pr\'econdition $B$, d'une postcondition $A$ et d'un programme $P$ repr\'esent\'e ainsi : $\{B\}P\{A\}$. Le triplet est vrai si pour tout valuation qui rend $B$ vraie et telle que $P$ s'arr\^ete, alors, apr\`es l'ex\'ecution et l'arr\^et de $P$, $A$ est vraie.
		
		

		\subsection*{Les outils}
		Ils existent diff\'erents outils pour prouver ou certifier des programmes. Il y a des assistants de preuve tel que Coq ou Isabelle qui permettent de d\'emontrer des th\'eor\`emes math\'ematiques. En mod\'elisant math\'ematiquement le comportement du programme, il est donc possible de prouver sa correction. \par
	D'autres logiciels permettent la preuve de programme en se sp\'ecialisant dans des langages pr\'ecis. Par exemple, \verifast{} a \'et\'e con\c{c}u pour le C et le java.
		\subsection*{Courte description de \verifast{}}
			\verifast{} est un outil de v\'erification d\'eductive de programme, C ou Java, avec un seul ou plusieurs threads. L'outil vous assure qu'il n'y a pas d'acc\`es ill\'egaux \`a la m\'emoire, que les pr\'econditions et postconditions sont bien respect\'ees et qu'il n'y est pas de probl\`eme de concurrence. Il est principalement con\c{c}u par Bart Jabocs, Jan Smans et Frank Piessens \`a l'universit\'e de Leuven en Belgique. \verifast{} est bas\'e sur la logique de s\'eparation, la logique multi-sorted et r\'esout les \'enonces math\'ematiques avec les SMT-solvers Redux et Z3.
		\subsection*{Exemple : Quicksort avec \verifast{} et d'autres....}
		\subsection*{Contributions}
		Il y a eu trois contributions concernant \verifast{}. Pour des raisons pratiques, les trois contributions ont \'et\'e fait simultan\'ement.
			\subsubsection{Integrer la theorie des tableaux}
				Z3 a des fonctions primitives pour la th\'eorie des tableaux mais \verifast{} ne les utilise pas. La premi\`ere contribution a \'et\'e d'enrichir la logique de \verifast{} en y ajoutant des fonctions repr\'esentant la th\'eories des tableaux afin de les relier aux fonctions primitives de Z3. \par
				La th\'eorie des tableaux permet de simplifier certaines preuves comme celle du quicksort.
			\subsubsection{Biblioth\`eque sur les tableaux et les multi-ensembles}
			Afin de prouver l'algorithme du quicksort, deux biblioth\`eques ont \'et\'e cr\'ees. La premi\`ere concerne les tableaux et la deuxi\`eme les multi-ensembles.

			\subsubsection{Preuve de quicksort}
			Il n'y avait pas de preuve du quicksort dans \verifast{}. \par Prouver l'algorithme permettait \`a la fois d'enrichir les preuves de \verifast{} mais aussi de v\'erifier l'int\'egration de la th\'eorie des tableaux.


\chapter{Logique du premier ordre}
	\section{Logique du premier ordre}
		\subsection{Syntaxe}
		On introduit la syntaxe de la logique du premier ordre (FOL) dans le contexte d'une paire $\sum = (\sum^s,\sum^f)$, que nous appelons la signature tel que :
		\begin{itemize}
		\item $\sum^s = \{ \sigma_{1}, \sigma_{2},...\}$ est un ensemble de symboles de type. On suppose l'existence d'un type location $Loc \in \sum^{s}$ et d'un type $Bool = \{ \top , \bot \}$, o\`u nous \'ecrivons $\top$ et $\bot$ pour les constantes, respectivement, true et false.
		\item $\sum^f = \{ f, g, h,...\}$ est un ensemble de symbole de fonctions. Pour un symbole de fonction $f^{\sigma_{1}\sigma_{2}... \sigma_{n}\sigma}$, $n \geq 0$ est son arit\'e et $\sigma_{1}\sigma_{2}... \sigma_{n}\sigma$ est sa signature o\`u $\sigma_{1}\sigma_{2}... \sigma_{n} \in \sum^{s}$ sont les types des arguments et $\sigma$ est le type du r\'esultat. Un symbole de fonctions d'arit\'e 0 est un symbole de constante $c^{\sigma}$ de type $\sigma \in \sum^{s}$. Nous ne pr\'eciserons pas la signature du symbole de fonctions lorsque c'est inutile.
		\end{itemize}

	   Posons $Var = {x,y,z,...}$ un ensemble d\'enombrable de variable du premier ordre. Chaque variable $x^{\sigma} \in Var$ est associ\'e \`a un type $\sigma \in \sum^{s}$.
	   
\begin{definition} (Terme).
Un terme $t$ de type $\sigma \in \sum^{s}$, not\'e $t^{\sigma}$, sur une signature $\sum$ est d\'efini r\'ecrusivement par la grammaire :\\
$t^{\sigma} ::= x,$ ~~~~~~~~~~~~~~$x^{\sigma} \in Var$ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (variable) \par
$|$~~ $c,$ ~~~~~~~~~~~~~~$c^{\sigma} \in \sum^{f}$ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(constant) \par
$|$~~$\langle t_{1},...,t_{n}\rangle,$~~~~ $t_{1}^{\sigma_{1}},...,t_{n}^{\sigma_{n}} terms, \sigma = \sigma_{1} \times ... \times \sigma_{n}$~~~~(tuple) \par
$|$~~$f(t_{1},...,t_{n}),$~~~$f^{\sigma_{1} ...\sigma_{n} \sigma} \in \sum^{f}, t_{1}^{\sigma_{1}},...,t_{n}^{\sigma_{n}} ~terms$~~~~(function application)
\end{definition}
	Tout symbole de constante ou variable de type $\sigma$ est un terme de type $\sigma$. Si $t_{1},...,t_{n}$ sont des termes de types $\sigma_{1},...,\sigma_{n}$ et $f^{\sigma_{1} ...\sigma_{n} \sigma} \in \sum^{f}$ alors $\langle t_{1},...,t_{n}\rangle$ est un terme de type $\sigma_{1} \times ... \times \sigma_{n}$ et $f(t_{1},...,t_{n})$ est un terme de type $\sigma$.\par

Nous noterons $\tau_{\mathsmaller\sum}$ $(\textbf{x})$ l'ensemble de tous les termes construit utilisant les symboles de fonctions dans $\sum^{f}$ et les variables dans l'ensemble \textbf{x}. Nous \'ecrivons $\tau_{\mathsmaller\sum}$ pour l'ensemble $\tau_{\mathsmaller\sum}$ $(\emptyset)$ de termes ne contenant aucune variable.
\begin{definition} 
(Formule du premier ordre). Une formule du premier ordre une signature $\sum$ est d\'efini r\'ecursivement par la grammaire :\\
\\$\phi^{FOL} ::= \top$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(true)\par
~~~~~$|$~~$\bot$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(false)
\par
~~~~~$|$~~$t,$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$t^{Bool}$ $term$~~~~~~~~~~~~~~~~~~~~~~~~(termes bool\'een)\par
~~~~~$|$~~ $t_{1} \approx t_{2},$~~~~~~~~~~~~~~~~~~~~~~~~$t_{1}^{\sigma},t_{2}^{\sigma}$ $terms$~~~~~~~~~~~~~~~~~~~~~~~~~~(\'egalit\'e)\par
~~~~~$|$~~$\neg\psi^{FOL}$,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(n\'egation)\par
~~~~~$|$~~$\phi_{1}^{FOL} \land \phi_{2}^{FOL},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(conjonction)\par
~~~~~$|$~~$\phi_{1}^{FOL} \lor \phi_{2}^{FOL},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(disjonction)\par
~~~~~$|$~~$\exists x.\phi^{FOL},$~~~~~~~~~~~~$x\in FV(\phi^{FOL})$~~~~~~~~~~~~~~~(quantificateur existentiel)\par
~~~~~$|$~~$\forall x.\phi^{FOL},$~~~~~~~~~~~~$x\in FV(\phi^{FOL})$~~~~~~~~~~~~~~~(quantificateur universel)
\end{definition}
Les constantes $\top$ et $\bot$, des termes bool\'een, et l'\'egalit\'e entre deux termes de m\^eme type sont des formules du premier ordre. La n\'egation, conjonction, disjonction, les quantificateurs existentiel et universelle de la logique du premier ordre sont aussi des formules de la logique du premier ordre.\par
	Pour une formule $\phi$, nous noterons $FV(\phi)$ l'ensemble des variables n'apparaissant pas dans la port\'ee d'un quantificateur de $\phi$.

\begin{definition}
(Substitution). Soit un ensemble de variables \textbf{x} et \textbf{y}, une substitution $\theta :$ \textbf{x} $\rightarrow \tau_{\smallsum}(\textbf{y})$ associe chaque variable dans \textbf{x} \`a un terme dans $\tau_{\mathsmaller\sum}(\textbf{y})$.
\end{definition}
	\subsection{S\'emantique}
	Les s\'emantiques des FOL formules sont d\'efinis en utilisant l'interpr\'etation des types et des fonctions dans une signature $\sum$ et l'\'evaluation des variables dans $Var$.
\begin{definition}
(Interpr\'etation). Une interpr\'etation $I$ pour $\sum$ associe chaque symbole de type $\sigma \in \sum^{s}$ \`a un ensemble non-vide $\sigma^{I}$, chaque symbole de fonction $f^{\sigma_{1},...,\sigma_{n}\sigma} \in \sum^{f}$ avec $n > 0$ \`a une fonction totale $f^{I} : \sigma_{1}^{I}\times ... \times \sigma_{n}^{I}$ et chaque symbole de constante $c^{\sigma} \in \sum^{f}$ \`a un \'el\'ement de $\sigma^{I}$.
\end{definition}
	Posons $I$ une interpr\'etation, $f^{\sigma_{1} ...\sigma_{n} \sigma}$ un symbole de fonction et $\alpha^{\sigma_{1}^{I},...,\sigma_{n}^{I}\sigma^{I}}$ une fonction. Nous \'ecrivons $I[f \leftarrow \alpha]$ pour une interpr\'etation tel que : \\(i) $I[f\leftarrow\alpha](\sigma) = I(\sigma)$, (ii) $I[f\leftarrow\alpha](f) = \alpha$, et (iii) $\nu[f\leftarrow\alpha](g) = g^{I}$ pour tout $g \in \sum^{f}$ avec $g\neq f$.
	
\begin{definition}
(Evaluation). Soit une interpr\'etation $I$, une \'evaluation $\nu$ chaque variable $x^{\sigma} \in Var$ \`a un \'el\'ement de $\sigma^{I}$.
\end{definition}
Notons $V_{I}$ l'ensemble des \'evaluation possible sous $I$.
Posons $I$ une interpr\'etation, $\nu \in V_{I}$ une \'evaluation, $x^{\sigma} \in Var$ une variable et $\alpha \in \sigma^{I}$ une valeur. Nous noterons $\nu[x\leftarrow\alpha]$ pour une \'evaluation tel que: (i) $\nu[x\leftarrow\alpha](x) = \alpha$, et (ii) $\nu[x\leftarrow\alpha](y)=\nu(y)$ pour tout $y\in Var$ avec $y\neq x$.

\begin{definition}
(Interpr\'etation d'un terme). L'interpr\'etation de t relative \`a $I$ et $\nu$ est obtenu en repla\c{c}ant chaque symbole de fonction $f$ apparaissant dans $t$ par son interpr\'etation $f^{I}$ et chaque variable $x$ apparaissant dans $t$ par son \'evaluation $\nu(x)$.
\end{definition}
Maintenant que l'on sait comment interpr\'eter les termes avec une \'evaluation donn\'e, nous pouvons \'etendre la notion d'interpr\'etation aux formules du premier ordre.
\begin{definition}
(S\'emantique d'une formule du premier ordre). Soit une interpr\'etation $I$ et une \'evaluation $\nu \in V_{I}$, nous \'ecrivons $I,\nu\models\phi$ si la formule du premier ordre $\phi$ est interpr\'et\'e par true sous $I$ et $\nu$. La relation est d\'efini inductivement sur la structure de $\phi$ :\par
$I,\nu\models\top$~~~~~~~~~~~~toujours vrai\par
$I,\nu\models\bot$~~~~~~~~~~~~jamais vrai\par
$I,\nu\models t$~~~~~~~~~~~~ ssi $t^{I}_{\nu}=\top,t^{Bool}$ term\par
$I,\nu\models t_{1}\approx t_{2},$~~~~~ssi $t^{I}_{1_{\nu}}=t^{I}_{2_{\nu}},t^{\sigma}_{1}=t^{\sigma}_{2}$ terms\par
$I,\nu\models\neg\psi$~~~~~~~~~~ssi $I,\nu\models\psi$ doesn't hold\par
$I,\nu\models\phi_{1}\land\phi_{2}$~~~~~ssi $I,\nu\models\phi_{1}$ et $I,\nu\models\phi_{2}$\par
$I,\nu\models\phi_{1}\lor\phi_{2}$~~~~~ssi $I,\nu\models\phi_{1}$ ou $I,\nu\models\phi_{2}$\par
$I,\nu\models\exists x.\psi$~~~~~~~~~ssi $I,\nu[x\leftarrow\alpha]\models\psi, x^{\sigma}\in FV(\psi),$ pour certains $\alpha\in\sigma^{I}$\par
$I,\nu\models\forall x.\psi$~~~~~~~~~ssi $I,\nu[x\leftarrow\alpha]\models\psi, x^{\sigma}\in FV(\psi),$ pour tout $\alpha\in\sigma^{I}$
\end{definition}

En utilisant leurs s\'emantiques, nous pouvons d\'efinir les notions de satisfaisabilit\'e  et d'implication des FOL formules sous une interpr\'etation $I$.

\begin{definition}
(Satisfaisable et valide). Une formule du premier ordre $\phi$ est satisfaisable dans l'interpr\'etation $I$ s'il existe une \'evaluation $\nu$ tel que $I,\nu\models\phi$ et insatisfaisable sinon. Si $I,\nu\models\phi$ pour tout $\nu$, alors $\phi$ est valide et $\neg\phi$ est insatisfaisable.
\end{definition}

\begin{definition}
(Implication et \'equivalence). Soit deux formules du premier ordre $\phi_{1}$ et $\phi_{2}$, nous \'ecrivons $\phi_{1}\models^{I}\phi_{2}$ et posons que $\phi_{1}$ implique $\phi_{2}$ dans l'interpr\'etation de $I$ ssi $I,\nu\models\phi_{1}$ implique $I,\nu\models\phi_{2}$ pour tout \'evaluation $\nu$. Nous appelons $\phi_{1}$  et $\phi_{2}$  \'equivalent si $\phi_{1}\models^{I}\phi_{2}$ et $\phi_{2}\models^{I}\phi_{1}$.
\end{definition}\par
Nous encapsulerons toutes les notions se rapportant \`a FOL dans les th\'eories du premier ordre.

\begin{definition}
(Th\'eorie du premier ordre). Une th\'eorie du premier ordre est une paire $T=(\mathsmaller \sum,M)$ tel que $\mathsmaller \sum$ est une signature et $M$ est un ensemble non vide de paire ($I,\nu$), appel\'e un mod\`ele de $T$, o\`u $I$ est une interpr\'etation et $\nu\in V_{I}$ est une \'evaluation.
\end{definition}

Soit une th\'eorie du premier ordre $T = (\mathsmaller \sum,M)$, tout $\mathsmaller \sum$-terme t est aussi appel\'e un $T$-terme et tout $\mathsmaller \sum$-formule $\phi$ est aussi appel\'e une $T$-formule. Une paire ($T,\nu$)$\in M$ tel que $T,\nu\models\phi$ est un $T$-mod\`ele de $\phi$. Nous noterons l'ensemble de tout les $T$-mod\`ele de $\phi$ par $\phibra_{T} = \{(T,\nu)\in M | I,\nu\models\phi\}$.

\begin{definition}
($T$-satisfaisable et $T$-valide). Soit $T = (\mathsmaller\sum,M)$ une th\'eorie du premier ordre, une $T$-formule $\phi$ est $T$-satisfaisable si $\phibra_{T} \neq \emptyset$ sinon $T$-insatisfaisable. Si $\phi$ est $T$-satisfaisable si et seulement si $\psi$ est $T$-satisfaisable alors $\phi$ et $\psi$ sont \'equisatisfaisable dans T. Si $\phibra_{T} = M$ alors $\phi$ est $T$-valide et $\neg\phi$ est $T$-insatisfaisable.
\end{definition}

\begin{definition}
($T$-mplication et $T$-\'equivalence). Soit une th\'eorie du premier ordre $T = (\mathsmaller \sum,M)$ et deux $T$-formule $\phi$ et $\psi$, nous \'ecrivons $\phi\models^{T}\psi$ et posons que $\phi$ $T$-implique $\psi$ si et seulement si $\phibra_{T}\subseteq \psibra_{T}$. Nous appelons $\phi$  et $\psi$  $T$-\'equivalent si $\phi\models^{T}\psi$ et $\psi\models^{T}\phi$.
\end{definition}\par
	\section{Logique de s\'eparation}
		\subsection{Syntaxe}
	La syntaxe de la logique de logique de s\'eparation (SL) est construit sur la syntaxe de FOL, d\'efini \`a la section 1.1.1. Nous consid\'erons une th\'eorie du premier ordre $T=(\mathsmaller\sum,M)$ tel que $\sum^{s}$ contiennent les types $Loc$ et $Data$ et $\sum^{f}$ contient une constante $nil^{Loc}$.
	\begin{definition}
	(Formule de la logique de s\'eparation). Une formule SL s'\'ecrit avec les m\^emes r\`egles qu'une formule FOL en ajoutant ces r\`egles :
	\\$\phi^{SL} ::= \top$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(true)\par
~~~~~$|$~~$\bot$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(false)
\par
~~~~~$|$~~$t,$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$t^{Bool}$ $term$~~~~~~~~~~~~~~~~~~~~~~~~(termes bool\'een)\par
~~~~~$|$~~ $t_{1} \approx t_{2},$~~~~~~~~~~~~~~~~~~~$t_{1}^{\sigma},t_{2}^{\sigma}$ $termes$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(\'egalit\'e)\par
~~~~~$|$~~emp~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(empty heap)\par
~~~~~$|$~~$t\mapsto u,$~~~~~~~~~~~~~~~~~~~~~$t^{Loc},u^{Data}$ $T$-termes ~~~~~~~~~~(singleton heap)\par 
~~~~~$|$~~$\neg\psi^{SL}$,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(n\'egation)\par
~~~~~$|$~~$\phi_{1}^{SL} \land \phi_{2}^{SL},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(conjonction)\par
~~~~~$|$~~$\phi_{1}^{SL} \lor \phi_{2}^{SL},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(disjonction)\par
~~~~~$|$~~$\phi_{1}^{SL} * \phi_{2}^{SL},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(conjonction s\'eparation)\par
~~~~~$|$~~$\phi_{1}^{SL} \sepimp \phi_{2}^{SL},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(implication s\'eparation)\par
~~~~~$|$~~$\exists x.\psi^{SL},$~~~~~~~~~~~~$x\in FV(\psi^{SL})$~~~~~~~~~~~~~~~(quantificateur existentiel)\par
~~~~~$|$~~$\forall x.\psi^{SL},$~~~~~~~~~~~~$x\in FV(\psi^{SL})$~~~~~~~~~~~~~~~(quantificateur universel)
	\end{definition}
	Les constantes $\top$ et $\bot$, des termes bool\'een, et l'\'egalit\'e entre deux termes de m\^eme type sont des formules SL($T$). La n\'egation, conjonction, disjonction, les quantificateurs existentiel et universelle sont aussi des formules SL($T$).
	Les deux nouveaux atomes d\'ecrivant le vide et le singleton de la heap sont des formules SL($T$).\par
	Si une SL($T$)-formule contient au moins une fois emp, $\mapsto$, $*$ ou $\sepimp$ alors c'est une formule \textit{spatial} sinon c'est une formule \textit{pure}.\par
	La plupart des d\'efinition de data structure, tel que des listes ou des arbres, utilise un fragment restreint sans quantificateur appel\'e \textit{symbolic heaps}.
\begin{definition}
(Formule de symbolic heap). Une formule de \textit{symbolic heap} est une conjonction $\Pi\land\Theta$ entre une pure $(\Pi)$ et une spatiale $(\Theta)$ partie, d\'efini ainsi :\\
$\Pi ::= \top$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(true)\par
$|$ $\bot$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(false)\par
$|$ $t,$~~~~~~~~~~~~~$t^{Bool}$ $T$-terme~~~~~~~~~~~~(boolean variable)\par
$|$ $t_{1}\approx t_{2},$~~~~~~~$t^{Loc}_{1},t^{Loc}_{2}$ $T$-termes~~~~~(egalit\'e)\par
$|$ $\neg(t_{1}\approx t_{2}),$~~~$t^{Loc}_{1},t^{Loc}_{2}$ $T$-termes~~~~~(inegalit\'e)\par
$|$ $\Pi_{1}\land\Pi_{2},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(conjonction)\\
$\Theta ::=$ emp~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(empty heap)\par
$|$ $t\mapsto u,$~~~~~$t^{Loc},u^{Data}$ $T$-termes~~~~~~(singleton heap)\par
$|$ $\Theta_{1}*\Theta_{2},$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(conjonction s\'eparation)
\end{definition}

	\subsection{S\'emantique}
	\begin{definition}
	(Heap).Soit une interpr\'etation $I$, la heap est une partie fini associant une location avec une data, $h : Loc^{I} \rightarrow_{fin} Data^{I}$. Nous utiliserons $Heaps^{I}$ pour repr\'esenter l'ensemble de toutes les heaps sous l'interpr\'etation de $I$.
	\end{definition}
	Deux heaps $h_{1}$ et $h_{2}$ sont disjointes si dom($h_{1}$)$\cap$dom($h_{2}$) $= \emptyset$ et nous l'\'ecrivons $h_{1}\#h_{2}$. L'union disjointes sera symbolis\'e par $h_{1}\cupdot h_{2}$ qui est ind\'efini if $h_{1}$ et $h_{2}$ ne sont pas disjoints. Nous \'ecrivons $\bigcupdot H$ pour l'union disjointes des heaps dans l'ensemble $H \subseteq Heaps$.
	\begin{definition}
	(S\'emantique de formule SL). Soit une interpr\'etation $I$, une \'evaluation $\nu\in V_{I}$ et une heap $h\in Heaps$, nous \'ecrivons $I,\nu,h\models^{SL}\phi$ si une formule SL $\phi$ est interpr\'et\'e \`a true sous $I,\nu$ et $h$. Cette relation est d\'efini par induction  dans la structure de $\phi$ :\par
	$I,\nu,h\models^{SL}\top$~~~~~~~~~~~toujours vrai\par
$I,\nu,h\models^{SL}\bot$~~~~~~~~~~jamais vrai\par
$I,\nu,h\models^{SL} t$~~~~~~~~~~ ssi $t^{I}_{\nu}=\top,t^{Bool}$ $T$-terme\par
$I,\nu,h\models^{SL} t_{1}\approx t_{2},$~~~ssi $(t_{1})^{I}_{\nu}=(t_{2})^{I}_{\nu},t^{\sigma}_{1},t^{\sigma}_{2}$ $T$-termes\par
$I,\nu,h\models^{SL}$emp ~~~~~~ssi dom($h$)=$\emptyset$\par
$I,\nu,h\models^{SL}t\mapsto u$~~~~~ssi $t^{I}_{\nu}\neq nil^{I}$ et $h = \{(t^{I}_{\nu},u^{I}_{\nu} )\}, t^{Loc}, u^{Loc}_{i}$ $T$-termes \par
$I,\nu,h\models^{SL}\neg\psi$~~~~~~~~ssi $I,\nu,h\models^{SL}\psi$ doesn't hold\par
$I,\nu,h\models^{SL}\phi_{1}\land\phi_{2}$~~~ssi $I,\nu,h\models^{SL}\phi_{1}$ et $I,\nu,h\models^{SL}\phi_{2}$\par
$I,\nu,h\models^{SL}\phi_{1}\lor\phi_{2}$~~~ssi $I,\nu,h\models^{SL}\phi_{1}$ ou $I,\nu,h\models^{SL}\phi_{2}$\par
$I,\nu,h\models^{SL}\phi_{1}*\phi_{2}$~~~~~~ssi $\exists h_{1}\exists h_{2}.h=h_{1}\cupdot h_{2}$ et $I,\nu,h_{1}\models^{SL}\phi_{1}$ et $I,\nu,h_{2}\models^{SL}\phi_{2}$\par
$I,\nu,h\models^{SL}\phi_{1}\sepimp\phi_{2}$~~ssi $\forall h_{0}.h\#h_{0}$ et $I,\nu,h_{0}\models^{SL}\phi_{1}$ implique \\$I,\nu,h\cupdot h_{0}\models^{SL}\phi_{2}$\par
$I,\nu,h\models^{SL}\exists x.\psi$~~~~~ssi $I,\nu[x\leftarrow v],h\models^{SL}\psi, x^{\sigma}\in FV(\psi),$ \\pour certains $v\in\sigma^{I}$\par
$I,\nu,h\models^{SL}\forall x.\psi$~~~~~~~ssi $I,\nu[x\leftarrow v],h\models^{SL}\psi, x^{\sigma}\in FV(\psi),$ pour tout $v\in\sigma^{I}$
	\end{definition}
	Un tripl\'e $(I,\nu,h)$ tel que $(I,\nu)\in M$ et $I,\nu,h\models^{SL}\phi$ est un SL($T$)-mod\`ele pour la SL($T$)-formule $\phi$. Nous noterons l'ensemble de tout les SL($T$)-mod\`ele de $\phi$ par $\phibra_{SL(T)} = \{(I,\nu,h)|(I,\nu)\in M,h\in Heaps^{I}$ et $I,\nu,h\models^{SL}\phi\}$. En utilisant ces notations et la s\'emantique au-dessus, nous d\'efinirons la satisfaisabilit\'e et l'implication de SL($T$)-formules.
\begin{definition}
(SL$(T)$-satisfaisable et SL$(T)$-valide). Soit un th\'eorie du premier ordre T = $(\smallsum,M)$, une SL$(T)$-formule $\phi$ est SL$(T)$-satisfaisable si $\phibra_{SL(T)}\neq\emptyset$ et SL$(T)$-insatisfaisable sinon. Si $\psi$ est SL$(T)$-satisfaisable si et seulement si $\phi$ est SL$(T)$-satisfaisable, alors $\phi$ et $\psi$ sont \textit{\'equisatisfaisable} dans SL$(T)$. Si $\phibra_{SL(T)}=M$ alors $\phi$ est $T$-valide et $\neg\phi$ est SL$(T)$-insatisfaisable.
\end{definition}

\begin{definition}
(SL$(T)$-implication et SL$(T)$-\'equivalence). SOoit une th\'eorie du premier ordre $T=(\smallsum,M)$ et deux SL$(T)$-formule $\phi$ et $\psi$, nous \'ecrivons $\phi\models^{SL}_{T}\psi$ et disons que $\phi$ SL$(T)$-implique $\psi$ si et seulement si $\phibra_{SL(T)}\subseteq\psibra_{SL(T)}$. Nous appelons $\phi$ et $psi$ $T$-\'equivalent quand  $\phi\models^{SL}_{T}\psi$ et $\psi\models^{SL}_{T}\phi$. 
\end{definition}

\begin{definition}
(Satisfaisable et valide). Une formule SL $\phi$ est satisfaisable si il existe une \'evaluation $\nu$ et une heap $h$ tel que $\nu,h\models^{SL}\phi$ et \textit{insatisfaisable} sinon. Si $\nu,h\models^{SL}\phi$ pour tout $\nu$ et $h$, alors $\phi$ est valide et $\neg\phi$ est insatisfaisable.
\end{definition}

\begin{definition}
(Implication et \'equivalence). Soit une formule SL $\phi$ et $\psi$, nous \'ecrivons $\phi\models^{SL}\psi$ et disons que $\phi$ implique $\psi$ si et seulement si $\nu,h\models^{SL}\phi$ implique $\nu,h\models^{SL}\psi$, pour tout \'evaluation $\nu$ et heap $h$. Nous appelons $\phi$ et $\psi$ \'equivelent quand $\phi\models^{SL}_{T}\psi$ et $\psi\models^{SL}_{T}\phi$. 
\end{definition}
	\section{Hoare}
	En pratique, une programme calcule soit la plus faible pr\'econdition n\'ecessaire pour que la postcondition soit respect\'e soit la plus forte postcondition. On les notera respectivement la plus $wp(P,A)$ et $sp(P, B)$. On aura donc \\$\forall B'$ tel que $\{B'\}P\{A\}$, $B' \rightarrow wp(P,A)$ et $\forall A'$ tel que $\{B\}P\{A'\}$, $sp(P,B) \rightarrow A'$. 
 	\section{D\'ecidabilit\'e des th\'eories}
 	

 		Une th\'eorie est un ensemble d'axiomes accompagn\'es de r\`egles de la logique. \par
		Sous une signature $\sigma$ et une th\'eorie $\tau_{\sigma}$, une formule $\phi$, construite dans $\sigma$, est satisfaisable in $\tau_{\sigma}$, si $\phi$ est \'evalu\'e \`a vrai sous toutes les interpr\'etations de $\tau_{\sigma}$.
 		Certaines th\'eories sont d\'ecidables. Une th\'eorie est d\'ecidable s'il existe un algorithme qui peut r\'epondre par oui ou par non \`a la question de savoir si un \'enonc\'e donn\'e est d\'emontrable dans cette th\'eorie. \par
 		Une th\'eorie est coh\'erente s'il existe des propositions non d\'emontrable. \par
 		Une th\'eorie est compl\`ete si toute proposition ou sa
 		n\'egation est d\'emontrable.
 		\subsection{Presburger}
 			L'arithm\'etique de Presburger est la th\'eorie  d\'ecidable du premier ordre des nombres entiers naturels muni de l'addition. En 1929, Mojzesz Presburger a d\'emontr\'e que son arithm\'etique est coh\'erente et compl\`ete.
 		\subsection{Array}
 			Les tableaux sont une data-structure pr\'esentes dans la plupart des langages de programmation. Il est donc int\'eressant de savoir quelles sont les propri\'et\'es d\'ecidable. \par

 			En logique, contrairement aux programmes, un tableau est de dimension infini. \par
 			Les tableaux sont \'equivalent \`a une fonction de type index vers range et nous allons leurs associ\'ees quatre op\'erations et un axiome propos\'e par McCarthy. \par
 			\subsubsection{Select}
 			Select(array a, index i) renvoie la valeur du tableau a \`a l'index i.\par
			 \subsubsection{Store}
			Store(array a, index i, range e) renvoie un nouveau tableau avec les m\^emes valeurs que le tableau a et la valeur e \`a l'index i.

 			\subsubsection{Extensionality}
 			Extensionality(array a, array b) renvoie un index i tel que
\par select$(a,i) = $ select$(b,i)\rightarrow a = b $

 			\subsubsection{Constant\_array}
 			Constant\_array(range v) renvoie un tableau a tel que \par
 			($\forall i$ : index) select(constant\_array$(v),i$) $= v$.

			\subsubsection{Axiome}
			L'axiome principal est : \par
 			($\forall a$ : array) ($\forall e$ : range)($\forall i,j$ : index) $i=j \rightarrow$ select(store($a,i,e$)$,j$) $ = e$
			\par $\land$ $i\neq j \rightarrow$ select(store($a,i,e$)$,j$) $=$ select($a,j$).
 		\subsection{Multiset}
 		Repr\'esentation des multiset en array(index, nat)

 	\section{Combinaison de th\'eories d\'ecidables}
 		La combinaison de th\'eories d\'ecidables est omni-pr\'esent dans la v\'erification de programme et il n'est pas \'evident que la combinaison reste d\'ecidable. Pour \'eviter d'avoir \`a produire une proc\'edure de d\'ecision pour chaque combinaison, on peut faire appel \`a des techniques de combinaison de proc\'edures de d\'ecisions.

 		En 1979, la m\'ethode de combinaison de Nelson-Oppen est pr\'esent\'e pour la premi\`ere fois. 20 ans plus tard, cette m\'ethode est adopt\'ee dans la plupart des solvers SMT. Cette m\'ethode se base sur le fait que si deux th\'eories $\tau$1 et $\tau$2 sont disjointes et stablement infinies alors la satisfaisabilit\'e de $\tau$1 $\lor$ $\tau$2 peut \^etre d\'eduite de la satisfaisabilit\'e de $\tau$1 $\lor \Lambda$ et $\tau$2 $\lor \Lambda$, o\`u $\Lambda$ est un ensemble d'informations partag\'ees. De ce fait, si on a deux proc\'edures de d\'ecision, une pour $\tau$1, et une autre pour $\tau$2, l'effort suppl\'ementaire pour v\'erifier la satisfaisabilit\'e de l'union est de trouver $\Lambda$. Ceci peut \^etre \'etendu \`a plus de deux th\'eories. \par
 		Deux th\'eories sont disjointes si aucun symbole n'appara\^it dans les deux th\'eories \`a la fois, except\'e des variables et le symbole d'\'egalit\'e. \par
 		Une th\'eorie est stablement infinie si toute formule sans quantificateur satisfaisable dans la \th\'eorie a un mod\`ele fini.

 		\par Les techniques de combinaison de d\'ecision sont essentielles \`a la construction des SMT solvers.

 	\section{SMT-solver}
 		Il existe de nombreux SMT-solver permettant de r\'esoudre des \'enonc\'es math\'ematiques. Tous ne r\'esolvent pas les \'enonc\'es des m\^emes th\'eories et ne sont aussi rapide. \verifast{} utilise deux SMT-solver, redux et Z3. Redux est plus rapide mais Z3 peut r\'esoudre des \'enonc\'es d'un plus grand nombre de th\'eorie.

 		- th\'eorie avec fonction non interpr\'et\'e \par
 		- Communication entre les th\'eories et un sat-solver \par
 		- Communication pour les axiomes "infini" entre le quantifier instantiation et le sat.

\chapter{V\'erification d\'eductive avec \verifast{}}
	\section{V\'erification d\'eductive de programmes}
		La v\'erification d\'eductive se base sur l'annotation des programmes. Le programme est annot\'e avec des formules logiques. Il y a les pr\'econditions (exigences sur les arguments de fonctions), les postconditions (garanties sur les r\'esultats de fonctions) et les invariants de boucle. Il restera \`a v\'erifier que pour chaque fonction, la fonction, accompagn\'ee de ces pr\'econditions, implique les postconditions et qu'\`a chaque appel de fonction, les pr\'econditions sont respect\'ees. Ces v\'erifications se feront \`a l'aide des SMT-solvers.
		\subsection{Logique de s\'eparation}
			swap(int*x, int*y)
	\section{Logique de sp\'ecification en \verifast{}}
		La sp\'ecification d'un programme est indiqu\'e en commentaires \`a l'aide de formules logiques. Ces formules logiques peuvent \^etre dans des pr\'edicats (objets logiques) ou dans des lemmes (fonctions logiques).
		\subsubsection{Predicats inductifs}
			Il est souvent utile d'utiliser des pr\'edicats inductifs pour repr\'esenter des propri\'et\'es. Par exemple, si on veut parler d'un tableau d'entier tri\'e entre deux bornes b et e, on peut construire le pr\'edicat suivant :
			\begin{lstlisting}
predicate sorted(array(int,int) arr,int b, int e) =
     (b >= e) ? true :
     select(arr,b) <= select(arr,b+1) &*& sorted(arr,b+1,e);
			\end{lstlisting}
		\subsubsection{Contrats}
			Chaque fonction est accompagn\'e d'au moins deux contrats, potentiellement vide. Les pre-conditions et les post-conditions, appel\'e "requires" et "ensures". Ces contrats doivent \^etre respect\'es pour que le programme soit consid\'er\'e comme correct. Par exemple, pour la fonction qui fait la moyenne de deux entiers :
			\begin{lstlisting}
int mean(int x, int y)
	//@ requires true;
	//@ ensures (x+y)/2 == result;
	{
	  return x + (y - x) / 2;
	}
			\end{lstlisting}
	Pour cette exemple, requires est un contrat vide. En effet, on a besoin d'aucune condition suppl\'ementaire que ce que nous donne d\'ej\`a le programme C. Par contre, en post-condition, nous voulons \^etre sur que le programme retourne bien la moyenne entre x et y.\par
	Des conditions qui aurait pu \^etre utile mais qui ne sont pas dans cette exemples aurait \'et\'e de v\'erifier un possible overflow.
		\subsubsection{Appel de lemme et Ouverture/Fermeture de pr\'edicat}
			En plus des pre et post conditions, il est possible de faire appel \`a des lemmes ou d'ouvrir/fermer des pr\'edicats au milieu du programme.
		\subsubsection{Invariant de boucle}

		\subsection{Decreases pour assurer la terminaison des boucles}

\chapter{Impl\'ementation}
	L'objectif de l'impl\'ementation est d'int\'egrer les fonctions de la th\'eorie des tableaux dans \verifast{} pour qu'elles soient directement retransmis \`a Z3. Ces fonctions manipulent un type tableau qui \'etait absent dans la logique de \verifast{}. La premi\`ere \'etape fut donc d'ajouter un type primitif array dans la logique de \verifast{}.
	\section{Cr\'eation du type array}
		La syntaxe du type array est "array(a,b)", a \'etant le domaine et b le range.
		\subsection{R\`egle de typage}
			\subsubsection{G\'en\'ericit\'e}
			En logique, le domaine et le range du type tableau sont deux type g\'en\'erique, c'est \`a dire, ils peuvent \^etre de n'importe quel type. Un objectif \'etait donc d'impl\'ementer un type tableau tout aussi g\'en\'erique. Toutes les fonctions ont \'et\'e implement\'ees ainsi mais \verifast{} a pos\'e une limite. Il n'y a pas de fonction g\'en\'erique pour repr\'esenter les pointeurs d\'efinis. En effet, il y a seulement des fonctions "integer(int*,int)", "character(char*,char)", etc... qui repr\'esente des pointeurs d'entier, de char, etc. Il n'est donc pas possible actuellement de compl\'eter la biblioth\`eque des tableaux avec uniquement des lemmes g\'en\'erique. Il est, par exemple, impossible de dire qu'un tableau est bien d\'efini g\'en\'eriquement. La fonction array\_model, ci-dessous, indique qu'un tableau d'entier est bien d\'efini entre (a+b) et (a+e) si un entier est bien d\'efini en (a+b) et qu'un tableau est bien d\'efini entre (a+b+1) et (a+e).
\begin{lstlisting}
.predicate array_model (int* a, int b, int e, array(int,int) arr) =
  (b >= e) ? true : (integer(a+b,?v) &*& select(arr, b) == v
  &*& array_model(a, b+1, e, arr));
\end{lstlisting}
			\subsubsection{Limite du domaine}
			S'il existe un type t de type : t $\rightarrow$ p, p \'etant un type quelconque, des termes tel que $(\lambda x. \neg(xx))(\lambda x.\neg(xx))$ 	deviennent typable alors qu'ils ne sont pas coh\'erent. Or, un tableau est comme fonction de type : domain $\rightarrow$ range. Je n'ai pas de preuve qu'avec les axiomes et les fonctions sur les tableaux le syst\`eme devient incoh\'erent, mais dans le doute, les tableaux de ce type ont \'et\'e interdit.
			\subsubsection{Type habit\'e}
				Dans \verifast{}, tous les types doivent \^etre habit\'e, c'est \`a dire, tous les types doivent avoir au moins un \'el\'ement. En effet, il existe cet axiome dans \verifast{} :
		\begin{lstlisting}
		fixpoint t default_value<t>();
		\end{lstlisting}
		Cet axiome retourne un \'el\'ement du type t. Donc s'il existe un type non-habit\'e alors le syst\`eme n'est plus coh\'erent. \par
		Par exemple, avec le type stream :
\begin{lstlisting}
inductive stream = Cons (int, stream);
\end{lstlisting}
Il est possible de prouver faux avec ces deux fonctions :
\begin{lstlisting}
lemma void no_stream (stream x)
	//@ requires true;
	//@ ensures false;
	{ switch (x) : {
		case Cons(_,s) { no_stream(s); }
	}

lemma void absurd()
	//@ requires true
	//@ ensures false
	{ no_stream(default_value<stream>())}

		\end{lstlisting}
\par De plus, l'implication
				$\forall x. P(x) \rightarrow \exists x. P(x)$ est utilis\'e dans la logique de \verifast{} et n'est vrai que si le type de $x$ est habit\'e.
			\subsubsection{Type infini}
				Exemple : utilisation de l'in\'egalit\'e pour montrer l'\'egalit\'e. si x peut \^etre a, b ou c. x!= a et x!= b -> x == c.

	\section{ProverArray}
		La logique multi-sorted de \verifast{} \'etait compos\'e des types int, boolean, real et inductive. Le type inductive est un type g\'en\'erique, c'est \`a dire, il existe des fonctions de boxing/unboxing pour transformer un type vers le type inductive et inversement. \par
		Les sorts de la logique de \verifast{} sont les types qui pourront \^etre transmis au solver Z3. Or, pour utiliser les fonctions sur les tableaux, le type primitif array est n\'ecessaire. Une \'etape fut donc de cr\'eer un nouveau type primitif array qui pourra \^etre transmis \`a Z3.\par
		\subsection{Int\^eret du type Inductive}
			Le type inductive a un r\^ole tr\`es particulier dans \verifast{}. En plus de repr\'esenter les types g\'en\'eriques, le type inductive est un moyen de communiquer \`a la fois \`a des solvers multi-sorted et \`a des solvers one-sorted. En effet, \verifast{} utilise deux solvers qui sont Redux et Z3. Redux n'a pas de type alors que Z3 en a. Comme indiqu\'e en (2.1), il existe une r\'eduction de la logique multi-sorted vers la one-sorted. \verifast{} peut donc ais\'ement communiquer \`a Redux m\^eme s'il n'utilise pas directement la m\^eme logique. Pour transformer tous les sorts vers un seul sort, \verifast{} utilise des fonctions de boxing.
			\subsubsection{Fonctions de boxing}
			Une fonction de boxing est une fonction qui transforme une valeur d'un certain type vers le type inductive. Il existe, par dualit\'e, des fonctions d'unboxing afin de retrouver la valeur initiale. Donc si $f$ est la fonction de boxing des entiers et $g$ la fonction d'unboxing alors $f(g(2)) = 2$ et $g(f(2)) = 2$.
		\subsection{Repr\'esentation du type array dans le solver Z3}
			Dans le Z3, le type array de Z3 est un type avec deux arguments. Ces arguments repr\'esentent le domaine et le range du tableau. Une premi\`ere impl\'ementation consista donc \`a r\'ecup\'erer les deux types et de les transmettre \`a Z3 au moment de la cr\'eation d'un tableau.
			\subsubsection{Pourquoi array inductive inductive dans z3}
			\subsubsection{Communication avec Z3}
			\subsubsection{Repr\'esentation dans \verifast{}}
	\section{Ajout des fonctions}
	Pour terminer l'impl\'ementation, il faut maintenant ajouter les fonctions select, store, constant\_array et array\_ext (extensionalit\'e). Il y a deux \'etapes, la premi\`ere est de d\'efinir comment ces fonctions vont \^etre communiqu\'e \`a Z3. La deuxi\`eme est de choisir comment repr\'esenter  et r\'ecup\'erer ces fonctions dans le code de \verifast{}.
		\subsection{Communication avec les SMT-solvers}
		Dans \verifast{}, tous les solvers ont une api commune. Ainsi, si on veut ajouter de nouvelles fonctions pour communiquer avec Z3, on doit s'assurer que Redux sera aussi s'en occuper.
			\subsubsection{Redux}
			Redux consid\`ere les fonctions de la th\'eorie des tableaux commme des fonctions non-primitives et donc comme des fonctions d\'efini par l'utilisateur. Lors d'un appel d'une de ces fonctions, Redux fait donc un appel de fonction classique. Peu de choses sont possibles avec Redux et il faut donc \'eviter d'utiliser Redux si on veut utiliser la th\'eorie des tableaux.
			\subsubsection{Z3}
			Les fonctions sont des primitives de Z3. L'impl\'ementation consiste donc \`a appeler les fonctions avec les informations que nous fournira l'utilisateur.
		\subsection{Repr\'esentation dans \verifast{}}
		\verifast{} interdit \`a deux fonctions ou pr\'edicats d'avoir un nom identique. Cette r\`egle est primordiale car elle permet \`a \verifast{} de d\'efinir toutes les primitives dans des biblioth\`eques annexes. Les fonctions de la th\'eorie des tableaux ont \'et\'e d\'efini dans une nouvelle biblioth\`eque sous la forme de fonctions pures. Ainsi, tous les programmes ant\'erieurs sont rest\'es correct et les noms restent disponibles si la biblioth\`eque n'est pas incluse.\par
		Les fonctions de la th\'eorie sont donc, dans le code de \verifast{}, des fonctions comme des autres. Il faut maintenant savoir comment les rep\'erer pour utiliser les fonctions primitives de Z3. \par
		Une possibilit\'e aurait \'et\'e de modifier le parser et ainsi savoir directement quand est-ce qu'elles sont appel\'ees. Avec l'impl\'ementation actuelle, l'ajout des fonctions aurait n\'ecessit\'e un nombre injustifi\'e de modification dans plusieurs fichiers pour recopier, une seconde fois, ce qui est d\'ej\`a \'ecrit. Du coup, une autre solution a \'et\'e choisi. \par
		L'autre solution consiste \`a trouver un point pr\'ecis du code o\`u toutes les fonctions vont \^etre appel\'ees et o\`u un maximum de v\'erification auront d\'ej\`a \'et\'e fait. Ainsi, le moins possible d'\'etapes seront impl\'ement\'ees et donc produira un code propre et concis.\par
		Lors de la derni\`ere v\'erification int\'eressante pour les fonctions pures, un matching sur le nom des fonctions permet aux primitives de la th\'eorie d'\^etre rep\'er\'e et ainsi d'\^etre trait\'e comme les fonctions de la th\'eorie des tableaux.

\chapter{Quicksort}
\chapter{Conclusion}
\tableofcontents
\end{document}
