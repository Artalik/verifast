% Pour compiler:
% $ pdflatex plan.tex && bibtex plan && pdflatex plan.tex && pdflatex plan.tex

\documentclass[11pt,openany]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}
\usepackage{tikz}
\usepackage{syntax}
\usepackage{relsize,exscale}
\usepackage{stmaryrd}
\usepackage{amssymb,MnSymbol}
\usepackage{appendix}
\usepackage{geometry}
\usepackage{a4wide}

\newcommand{\verifast}{VeriFast}
\newcommand\sepimp{\mathrel{-\mkern-6mu*}}
\newcommand\phibra{\llbracket\phi\rrbracket}
\newcommand\psibra{\llbracket\psi\rrbracket}
\newcommand\smallsum{\mathsmaller\sum}

\lstset{language={C}}
\lstset{alsoletter={&},morekeywords={inductive,predicate,array,true,false,lemma,&*&}}
\lstset{showstringspaces=false}

\newtheorem{definition}{D\'efinition}[subsection]
\newtheorem{exemple}{Exemple}
\newtheorem{lemme}{Lemme}
\newtheorem{theorem}{Th\'eor\`eme}

\setcounter{tocdepth}{2}

\title{Ajout de la th\'eorie logique des tableaux dans VeriFast}
\author{Pierre Nigron}
\begin{document}

\maketitle
\sloppy

\tableofcontents

\section*{Introduction}
		Aujourd'hui, les programmes informatiques sont de plus en plus pr\'esents dans notre quotidien et ont certaines fois notre vie entre leurs lignes. En effet, si un bug informatique entra\^ine un accident dans le m\'etro ou fait exploser une fus\'ee, il risque d'y avoir des pertes humaines ou de lourdes pertes \'economiques.
		
		Malheureusement, v\'erifier qu'un programme est correct est ind\'ecidable. Par cons\'equent, la m\'ethode la plus courante est de tester un programme dans diff\'erents environnements. Cependant, on ne peut pas tester le nombre infini de vols possibles d'une fus\'ee. Les m\'ethodes de test permettent de conna\^itre le comportement r\'eel du programme dans un environnement pr\'ecis; \`a l'inverse, d'autres m\'ethodes utilisent un mod\`ele de l'ex\'ecution du programme pour d\'eterminer une approximation du comportement du programme dans de nombreux environnements. M\^eme si le r\'esultat est une approximation, ces m\'ethodes d\'etecteront si le programme se comporte correctement. Par contre, elle peut indiquer qu'un programme n'est pas correct alors qu'il l'est, mais ceci n'apporte aucun pr\'ejudice \`a la s\'ecurit\'e.

		Pour nous aider \`a prouver qu'un programme est correct, diff\'erents outils existent. Il y a des assistants de preuve tels que Coq ou Isabelle qui permettent de d\'emontrer des th\'eor\`emes math\'ematiques. En mod\'elisant math\'ematiquement le comportement du programme, il est donc possible de prouver sa correction. D'autres logiciels permettent la v\'erification d\'eductive de programme en se sp\'ecialisant dans des langages pr\'ecis, c'est en particulier le cas de l'outil \verifast{} sur lequel nous allons travailler. 
	
	Les m\'ethodes d\'eductives qui vont prouver qu'un programme imp\'eratif suit sa sp\'ecification utilisent souvent une logique qui sp\'ecifie les \'etats du programme. Cette logique est utilis\'e dans le triplet de Hoare muni d'axiomes et r\`egles pour toutes les instructions de base d'un langage imp\'eratif. Le triplet est constitu\'e d'une pr\'econdition $B$, d'une postcondition $A$ et d'un programme $P$ repr\'esent\'e ainsi : $\{B\}P\{A\}$. Le triplet est vrai si pour tout \'etat qui rend $B$ vraie et telle que $P$ s'arr\^ete, alors, apr\`es l'ex\'ecution et l'arr\^et de $P$, $A$ est vraie.
	
	Par exemple, \verifast{} est un outil de v\'erification d\'eductive de programme, C ou Java, avec un seul ou plusieurs threads. L'outil assure qu'il n'y a pas d'acc\`es ill\'egaux \`a la m\'emoire, que les pr\'econditions et postconditions sont bien respect\'ees et qu'il n'y ait pas de probl\`eme de concurrence. Il est principalement con\c{c}u par Bart Jabocs, Jan Smans et Frank Piessens \`a l'universit\'e de Leuven en Belgique. \verifast{} est bas\'e sur la logique de s\'eparation et r\'esout les \'enonc\'es math\'ematiques avec les SMT-solvers Redux et Z3.
	
	 Pour certains programmes comme les programmes de tri, il est naturel de les sp\'ecifier \`a l'aide des tableaux, des ensembles et des multi-ensembles. En effet, une sp\'ecification correcte d'un algorithme de tri est qu'il retourne un tableau tri\'e contenant le m\^eme multi-ensemble d'\'el\'ements que le tableau initial. Malheureusement ces tableaux, ensembles et multi-ensembles ne sont pas pr\'evus dans la logique de \verifast{} alors qu'ils sont pourtant bien trait\'es par Z3.
	 
	 Les contributions du TRE se sont s\'epar\'ees en plusieurs parties d\'ependantes les unes des autres. Une partie \'etait d'automatiser la th\'eorie des tableaux dans \verifast. En parall\`ele, une preuve de l'algorithme quicksort, absente dans \verifast, a \'et\'e \'ecrite. La preuve et l'automatisation de la th\'eorie ont conduit \`a la cr\'eation des biblioth\`eques de la th\'eorie des tableaux et des multi-ensembles.
	 
	Tout d'abord, nous nous int\'eresserons \`a la logique du premier ordre et aux proc\'edures de d\'ecision. Ensuite, nous \'evoquerons la v\'erification d\'eductive et plus particuli\`erement celle de \verifast. Enfin, nous aborderons les contributions apport\'ees par le TRE.

\section{Logique du premier ordre}
	\subsection{Syntaxe}
		On introduit la syntaxe de la logique du premier ordre (FOL) dans le contexte d'une paire $\Sigma = (\Sigma^s,\Sigma^f)$, que nous appelons la signature telle que :
		\begin{itemize}
		\item $\Sigma^s = \{ \sigma_{1}, \sigma_{2},\ldots\}$ est un ensemble de symboles de type (parfois aussi appell\'es symboles de sorte). On suppose l'existence d'un type $Bool = \{ \top , \bot \}$, o\`u nous \'ecrivons $\top$ et $\bot$ pour les constantes, respectivement, vrai et faux.
		\item $\Sigma^f = \{ f, g, h,\ldots\}$ est un ensemble de symboles de fonction. Pour un symbole de fonction $f^{\sigma_{1}\sigma_{2}\ldots \sigma_{n}\sigma}$, $n \geq 0$ est son arit\'e et $\sigma_{1}\sigma_{2}\ldots \sigma_{n}\sigma$ est sa signature o\`u $\sigma_{1}\sigma_{2}\ldots \sigma_{n} \in \Sigma^{s}$ sont les types des arguments et $\sigma$ est le type du r\'esultat. Nous ne pr\'eciserons pas la signature du symbole de fonctions lorsque c'est inutile.
		\end{itemize}

	   Posons $Var = {x,y,z,\ldots}$ un ensemble d\'enombrable de variables du premier ordre. Chaque variable $x^{\sigma} \in Var$ est associ\'ee \`a un type $\sigma \in \Sigma^{s}$.
	   
\begin{definition}
(Terme). La syntaxe des termes est d\'efinie r\'ecursivement par la grammaire suivante :

\begin{tabular}{lcll}
$t$ & $::=$ & $x$ & (variable) \\
 & $|$ & $f(t_1,\ldots,t_n)$ & (application)
\end{tabular}

\end{definition}	   
	   
\begin{definition} (Terme typ\'e).
Un terme $t$ est de type $\sigma\in\Sigma^s$ sur une signature $\Sigma$ (aussi appel\'e $\Sigma$-terme), not\'e $t^\sigma$, si et seulement si l'une des conditions suivantes est respect\'ee :
\begin{tabular}{lcll}
t & = & x & et $x^\sigma\in Var$\\
t & = & $f(t_1,\ldots,t_n)$ & $t_1^{\sigma_1},\ldots,t_n^{\sigma_n}$ et $f^{\sigma_1\ldots\sigma_n\sigma}\in\Sigma^f$

\end{tabular}
\end{definition}

	Tout symbole de variable de type $\sigma$ est un terme de type $\sigma$. Si $t_{1},\ldots,t_{n}$ sont des termes de type $\sigma_{1},\ldots,\sigma_{n}$ et $f^{\sigma_{1} \ldots\sigma_{n} \sigma} \in \Sigma^{f}$ alors $f(t_{1},\ldots,t_{n})$ est un terme de type $\sigma$.

Nous noterons $\tau_{\Sigma}$ $(\textbf{x})$ l'ensemble de tous les termes construit utilisant les symboles de fonctions dans $\Sigma^{f}$ et les variables dans l'ensemble \textbf{x}. Nous \'ecrivons $\tau_{\Sigma}$ pour l'ensemble $\tau_{\Sigma}$ $(\emptyset)$ de termes ne contenant aucune variable.
\begin{definition} 
(Formule du premier ordre). Une formule du premier ordre sur une signature $\Sigma$ (aussi appel\'ee $\Sigma$-formule) est d\'efinie r\'ecursivement par la grammaire :
\begin{tabular}{lclcl}
$\phi^{FOL}$ & $::=$ & $\top$ & & (vrai)\\
 & $|$ & $\bot$ & & (faux)\\
 & $|$ & $t,$ & $t^{Bool}$ & (termes bool\'eens)\\
 & $|$ & $t_{1} \approx t_{2},$ & $t_{1}^{\sigma},t_{2}^{\sigma}$ & (\'egalit\'e)\\
 & $|$ & $\neg\phi^{FOL},$ & & (n\'egation)\\
 & $|$ & $\phi_{1}^{FOL} \land \phi_{2}^{FOL}$ & & (conjonction)\\
 & $|$ & $\phi_{1}^{FOL} \lor \phi_{2}^{FOL}$ & & (disjonction)\\
 & $|$ & $\exists x.\phi^{FOL},$ & $x\in FV(\phi^{FOL})$ & (quantificateur existentiel)\\
 & $|$ & $\forall x.\phi^{FOL},$ & $x\in FV(\phi^{FOL})$ & (quantificateur universel)

\end{tabular}
\end{definition}
Les constantes $\top$ et $\bot$, des termes bool\'eens, et l'\'egalit\'e entre deux termes de m\^eme type sont des formules du premier ordre. La n\'egation, conjonction, disjonction, les quantificateurs existentiels et universels de la logique du premier ordre sont aussi des formules de la logique du premier ordre.

	Pour une formule $\phi$, nous noterons $FV(\phi)$ l'ensemble des variables n'apparaissant pas dans la port\'ee d'un quantificateur de $\phi$.

\begin{definition}
(Substitution). Soit un ensemble de variables \textbf{x} et \textbf{y}, une substitution $\theta :$ \textbf{x} $\rightarrow \tau_{\Sigma}(\textbf{y})$ associe chaque variable dans \textbf{x} \`a un terme dans $\tau_{\Sigma}(\textbf{y})$.
\end{definition}
	\subsection{S\'emantique}
		La s\'emantique des formules du premier ordre est d\'efinie en utilisant l'interpr\'etation des types et des fonctions dans une signature $\Sigma$ et l'\'evaluation des variables dans $Var$.
\begin{definition}
(Interpr\'etation). Une interpr\'etation $I$ pour $\Sigma$ associe chaque symbole de type $\sigma \in \Sigma^{s}$ \`a un ensemble non-vide $\sigma^{I}$, chaque symbole de fonction $f^{\sigma_{1},\ldots,\sigma_{n}\sigma} \in \Sigma^{f}$ avec $n > 0$ \`a une fonction totale $f^{I} : \sigma_{1}^{I}\times \ldots \times \sigma_{n}^{I}\rightarrow\sigma^I$.
\end{definition}
	Posons $I$ une interpr\'etation, $f^{\sigma_{1} \ldots\sigma_{n} \sigma}$ un symbole de fonction et $\alpha^{\sigma_{1}^{I},\ldots,\sigma_{n}^{I}\sigma^{I}}$ une fonction. Nous \'ecrivons $I[f \leftarrow \alpha]$ pour une interpr\'etation telle que : \\(i) $I[f\leftarrow\alpha](\sigma) = I(\sigma)$, (ii) $I[f\leftarrow\alpha](f) = \alpha$, et (iii) $\nu[f\leftarrow\alpha](g) = g^{I}$ pour tout $g \in \Sigma^{f}$ avec $g\neq f$.
	
\begin{definition}
(\'Evaluation). Soit une interpr\'etation $I$, une \'evaluation $\nu$ associe chaque variable $x^{\sigma} \in Var$ \`a un \'el\'ement de $\sigma^{I}$.
\end{definition}
Notons $V_{I}$ l'ensemble des \'evaluations possibles sous $I$.
Posons $I$ une interpr\'etation, $\nu \in V_{I}$ une \'evaluation, $x^{\sigma} \in Var$ une variable et $\alpha \in \sigma^{I}$ une valeur. Nous noterons $\nu[x\leftarrow\alpha]$ pour une \'evaluation telle que: (i) $\nu[x\leftarrow\alpha](x) = \alpha$, et (ii) $\nu[x\leftarrow\alpha](y)=\nu(y)$ pour tout $y\in Var$ avec $y\neq x$.

\begin{definition}
(Interpr\'etation d'un terme). L'interpr\'etation de t relative \`a $I$ et $\nu$ est obtenue en repla\c{c}ant chaque symbole de fonction $f$ apparaissant dans $t$ par son interpr\'etation $f^{I}$ et chaque variable $x$ apparaissant dans $t$ par son \'evaluation $\nu(x)$.
\end{definition}
Maintenant que l'on sait comment interpr\'eter les termes avec une \'evaluation donn\'ee, nous pouvons \'etendre la notion d'interpr\'etation aux formules du premier ordre.
\begin{definition}
(S\'emantique d'une formule du premier ordre). Soit une interpr\'etation $I$ et une \'evaluation $\nu \in V_{I}$, nous \'ecrivons $I,\nu\models\phi$ si la formule du premier ordre $\phi$ est interpr\'et\'ee par vrai sous $I$ et $\nu$. La relation est d\'efinie inductivement sur la structure de $\phi$ :

\begin{tabular}{rcll}
$I,\nu$ & $\models$ & $\top$ & toujours vrai\\
$I,\nu$ & $\models$ & $\bot$ & jamais vrai\\
$I,\nu$ & $\models$ & $t$ & ssi $t^{I}_{\nu}=\top,t^{Bool}$\\
$I,\nu$ & $\models$ & $t_{1}\approx t_{2},$ & ssi $t^{I}_{1_{\nu}}=t^{I}_{2_{\nu}},t^{\sigma}_{1}=t^{\sigma}_{2}$\\
$I,\nu$ & $\models$ & $\neg\phi$ & ssi $I,\nu\models\phi$ est faux\\
$I,\nu$ & $\models$ & $\phi_{1}\land\phi_{2}$ & ssi $I,\nu\models\phi_{1}$ et $I,\nu\models\phi_{2}$\\
$I,\nu$ & $\models$ & $\phi_{1}\lor\phi_{2}$ & ssi $I,\nu\models\phi_{1}$ ou $I,\nu\models\phi_{2}$\\
$I,\nu$ & $\models$ & $\exists x.\phi$ & ssi $I,\nu[x\leftarrow\alpha]\models\phi, x^{\sigma}\in FV(\phi),$ pour certains $\alpha\in\sigma^{I}$\\
$I,\nu$ & $\models$ & $\forall x.\phi$ & ssi $I,\nu[x\leftarrow\alpha]\models\phi, x^{\sigma}\in FV(\phi),$ pour tout $\alpha\in\sigma^{I}$

\end{tabular}
\end{definition}

En utilisant leurs s\'emantiques, nous pouvons d\'efinir les notions de satisfaisabilit\'e  et d'implication des formules du premier ordre sous une interpr\'etation $I$.

\begin{definition}
(Satisfaisable et valide). Une formule du premier ordre $\phi$ est satisfaisable dans l'interpr\'etation $I$ s'il existe une \'evaluation $\nu$ telle que $I,\nu\models\phi$. Sinon, la formule est insatisfaisable. Si $I,\nu\models\phi$ pour tout $\nu$, alors $\phi$ est valide et $\neg\phi$ est insatisfaisable.
\end{definition}

\begin{definition}
(Implication et \'equivalence). Soit deux formules du premier ordre $\phi_{1}$ et $\phi_{2}$, nous \'ecrivons $\phi_{1}\models^{I}\phi_{2}$ et disons que $\phi_{1}$ implique $\phi_{2}$ dans l'interpr\'etation de $I$ ssi $I,\nu\models\phi_{1}$ implique $I,\nu\models\phi_{2}$ pour toute \'evaluation $\nu$. Nous appelons $\phi_{1}$  et $\phi_{2}$  \'equivalentes si $\phi_{1}\models^{I}\phi_{2}$ et $\phi_{2}\models^{I}\phi_{1}$.
\end{definition}

	Nous encapsulerons toutes les notions se rapportant \`a la logique du premier ordre dans les th\'eories du premier ordre.

\begin{definition}
(Th\'eorie du premier ordre). Une th\'eorie du premier ordre est une paire $T=( \Sigma,M)$ telle que $ \Sigma$ est une signature et $M$ est un ensemble non vide de paire ($I,\nu$), appel\'e un mod\`ele de $T$, o\`u $I$ est une interpr\'etation et $\nu\in V_{I}$ est une \'evaluation.
\end{definition}

Une th\'eorie du premier ordre est coh\'erente s'il existe des formules non-d\'emontrables. Nous supposons que toutes les th\'eories, dont nous parlerons, sont coh\'erentes. Soit une th\'eorie du premier ordre $T = ( \Sigma,M)$, tout $ \Sigma$-terme t est aussi appel\'e un $T$-terme et tout $ \Sigma$-formule $\phi$ est aussi appel\'e une $T$-formule. Une paire ($I,\nu$)$\in M$ telle que $I,\nu\models\phi$ est un $T$-mod\`ele de $\phi$. Nous noterons l'ensemble des $T$-mod\`eles de $\phi$ par $\phibra_{T} = \{(I,\nu)\in M | I,\nu\models\phi\}$.

\begin{definition}
($T$-satisfaisable et $T$-valide). Soit $T = (\Sigma,M)$ une th\'eorie du premier ordre, une $T$-formule $\phi$ est $T$-satisfaisable si $\phibra_{T} \neq \emptyset$ sinon $T$-insatisfaisable. Si $\phi$ est $T$-satisfaisable si et seulement si $\psi$ est $T$-satisfaisable alors $\phi$ et $\psi$ sont \'equisatisfaisables dans T. Si $\phibra_{T} = M$ alors $\phi$ est $T$-valide et $\neg\phi$ est $T$-insatisfaisable.
\end{definition}

\begin{definition}
($T$-implication et $T$-\'equivalence). Soit une th\'eorie du premier ordre $T = ( \Sigma,M)$ et deux $T$-formules $\phi$ et $\psi$, nous \'ecrivons $\phi\models^{T}\psi$ et posons que $\phi$ $T$-implique $\psi$ si et seulement si $\phibra_{T}\subseteq \psibra_{T}$. Nous appelons $\phi$  et $\psi$  $T$-\'equivalent si $\phi\models^{T}\psi$ et $\psi\models^{T}\phi$.
\end{definition}

	Une th\'eorie peut \^etre construite \`a partir d'axiomes. Le mod\`ele d'une th\'eorie construite \`a partir d'axiomes est l'intersection des mod\`eles des axiomes.

	\subsection{Arithm\'etique de Presburger}
		L'arithm\'etique de Presburger est une th\'eorie du premier ordre. Elle est munie de la signature : $\Sigma^s = \{Nat\}$ et $\Sigma^{f}=\{0^{Nat},1^{Nat},+^{NatNatNat}\}$ et est accompagn\'ee des axiomes suivants :
		\begin{enumerate}
		\item $\forall x.$ $\neg(0\approx x+1)$
		\item $\forall x,y.$ $x + 1\approx y+1\rightarrow x\approx y$
		\item $\forall x.$ $x+0\approx x$
		\item $\forall x,y.$ $x+(y+1)\approx (x+y)+1$
		\item Soit $P(x)$ une formule du premier ordre dans le langage de l'arithm\'etique de Presburger avec la variable libre $x$,\\
		$(P(0)\land\forall x.(P(x)\rightarrow P(x+1)))\rightarrow\forall y. P(y)$
		\end{enumerate}
	\subsection{Th\'eorie des tableaux}	
		Un tableau logique est une expression qui associe un \'el\'ement \`a chaque indice. Nous notons le type des indices $\sigma_I$ (aussi appel\'e domaine) et le type des \'el\'ements $\sigma_E$ (aussi appel\'e co-domaine). Le type du tableau est not\'e $\sigma_A$.
		
		La th\'eorie des tableaux est muni de la signature : $\Sigma^s=\{\sigma_I,\sigma_E,\sigma_A\}$ et $\Sigma^f=\{select^{\sigma_A\sigma_I\sigma_E},store^{\sigma_A\sigma_I\sigma_E\sigma_A},constant\_array^{\sigma_E\sigma_A},array\_ext^{\sigma_A\sigma_A\sigma_I}\}$. Nous pouvons donc remarquer qu'il y a une signature diff\'erente pour chaque paire de types $(\sigma_I,\sigma_E)$ et donc une th\'eorie diff\'erente pour chaque paire de th\'eories sur les \'el\'ements et les indices.
	
	Posons $a\in \sigma_A$ un tableau, il y a 4 fonctions \'el\'ementaires \`a la th\'eorie :
	\begin{enumerate}
	\item \textit{Select} : Soit $i\in \sigma_I$, \textit{select(a,i)} renvoie la valeur de l'\'el\'ement \`a l'indice $i$.
	\item \textit{Store} :  Soit $i\in \sigma_I$ et $e\in \sigma_E$, \textit{store(a,i,e)} renvoie un nouveau tableau avec les m\^emes valeurs que le tableau $a$ et la valeur $e$ \`a l'indice $i$.
	\item \textit{Constant_array} : Soit $e\in \sigma_E$, \textit{constant\_array}($e$) renvoie un tableau tel que $\forall i\in \sigma_I$ $select(constant\_array(e),i)$ $= e$.
	\item \textit{Extensionalit\'e} : Soit $a,b\in \sigma_A$, \textit{array_ext}($a,b$) renvoie un indice $i$ tel que $select(a,i) = select(b,i)\rightarrow a = b $
	\end{enumerate}

L'axiome principal utilis\'e pour d\'efinir les fonctions \textit{select} et \textit{store} est l'axiome \textbf{read-over-write} :\\
	$\forall a\in \sigma_A.$ $\forall e\in \sigma_E.$ $\forall i,j\in \sigma_I.$\textit{select(store($a,i,e$)$,i$) $ = e$
			 $\land$ \\ $i\neq j \rightarrow$ select(store($a,i,e$)$,j$) $=$ select($a,j$)}.	
	
	Nous appelons les th\'eories utilis\'ees pour raisonner sur les indices et les \'el\'ements, \textit{th\'eorie des indices} et \textit{th\'eorie des \'el\'ements}.
	
	La logique des indices peut autoriser les quantificateurs pour mod\'eliser des propri\'et\'es telles que "Il existe un \'el\'ement du tableau qui est \'egal \`a z\'ero" ou "tout \'el\'ement du tableau est sup\'erieur ou \'egal \`a z\'ero". Un exemple de th\'eorie adapt\'ee est l'arithm\'etique de Presburger.
	
	\begin{definition}
(Tableau logique). La syntaxe d'un tableau logique est d\'efinie par extension des r\`egles de syntaxe de la logique des indices et la logique des \'el\'ements. Nous notons $form_{I}$/$term_{I}$ et $form_{E}$/$term_{E}$ les formules/termes de, respectivement, la logique des indices et la logique des \'el\'ements :\par
$form ::= form_{I}$ $|$ $form_{E}$ $|$ $\neg form$ $|$ $form\land form$ $|$ $\forall$ array-identifier$. form$\par
$term_{A} ::=$ array-identifier $|$ $store(term_{A},term_{I},term_{E})$ $|$ $constant\_array(term_{E})$\par
$term_{E} ::=$ $select(term_{A},term_{I})$\par
$term_{I} ::=$ $array\_ext(term_{A},term_{A})$

\end{definition}
	Nous pouvons observer que la grammaire n'autorise pas l'\'egalit\'e entre les tableaux. L'\'egalit\'e se fait avec la fonction d'extensionalit\'e, en supposant que l'\'egalit\'e est autoris\'ee entre les \'el\'ements du tableaux.
	
			
 	\subsection{Proc\'edures de d\'ecision}
 	\begin{definition}
 	(Probl\`eme de d\'ecision). Le probl\`eme de d\'ecision pour un formule $\phi$ est de d\'eterminer si $\phi$ est valide.
 	\end{definition}
 	\begin{definition}
 	(Correction d'une proc\'edure). Une proc\'edure pour un probl\`eme de d\'ecision est correcte si quand elle retourne \textit{Valide}, alors la formule en entr\'ee est valide.
 	\end{definition}
 	\begin{definition}
 		(Compl\'etude d'une proc\'edure). Une proc\'edure pour un probl\`eme de d\'ecision est compl\`ete si elle retourne valide pour toutes les formules valides.
 	\end{definition}
 	\begin{definition}
 	(Proc\'edure de d\'ecision). Soit $T$ une th\'eorie, une proc\'edure est appel\'ee \textit{proc\'edure de d\'ecision pour $T$} si elle est compl\`ete et correcte pour toutes les formules de $T$. 
 	\end{definition} 	
 	Un aspect important, pour prouver des programmes avec l'aide de la logique, est d'utiliser des th\'eories d\'ecidables.
	\begin{definition}
	(Th\'eorie d\'ecidable). Soit $T$ une th\'eorie logique du premier ordre, $T$ est d\'ecidable si et seulement s'il existe une proc\'edure de d\'ecision.
	\end{definition}
	Par exemple, l'arithm\'etique de Presburger est d\'ecidable. Mais en g\'en\'eral, une th\'eorie n'est pas d\'ecidable. Pour palier \`a ce probl\`eme, les th\'eories doivent \^etre syntaxiquement restreintes. On parle alors de fragment de la logique.
			
	\subsubsection{D\'ecidabilit\'e de la th\'eorie des tableaux}
			
	La th\'eorie des tableaux actuelle n'est pas d\'ecidable, m\^eme si la combinaison entre la th\'eorie des indices et la th\'eorie des \'el\'ements est d\'ecidable. Il faut limiter la syntaxe de la th\'eorie pour la rendre d\'ecidable.
	\paragraph{Tableaux comme des fonctions non-interpr\'et\'ees}
	Consid\'erons le fragment de la logique qui n'autorise pas les quantificateurs sur les tableaux. Un chemin possible pour rendre la th\'eorie des tableaux d\'ecidable est de r\'eduire chaque formule en une combinaison d'autres th\'eories qui tra\^ite les tableaux comme des fonctions non-interpr\'et\'ees.
	
	Les fonctions non-interpr\'et\'ees sont utilis\'ees pour abstraire, ou g\'en\'eraliser, des th\'eor\`emes. Contrairement aux autres symboles de fonctions, elles ne devraient pas \^etre interpr\'et\'ees comme une partie de la formule. Dans la formule suivante, par exemple, $F$ et $G$ sont non-interpr\'et\'ees alors que le symbole de fonction binaire "+" est interpr\'et\'e comme la fonction addition :
	
	
$F(x) = F(G(y)) \lor x+1=y$

Remplacer une fonction avec une fonction non-interpr\'et\'ee est une technique courante pour simplifier le raisonnement.	En contre-partie, une formule valide peut devenir invalide. Pour que ce remplacement soit correct, il faut que les fonctions non-interpr\'et\'ees suivent un axiome. L'axiome de la th\'eorie des fonctions non interpr\'et\'ees est que si on leur donne une entr\'ee identique, la sortie sera identique. C'est ce qu'on appelle une \textbf{coh\'erence fonctionnelle} ou encore \textbf{congruence fonctionnelle}.

Quand le tableau est une fonction non-interpr\'et\'ee, l'indice devient le seul argument de la fonction. La fonction \textit{store} peut \^etre manipul\'e en rempla\c{c}ant chaque expression de la forme $store(a,i,e)$ par une nouvelle variable $a'\in \sigma_A$ et en ajoutant deux formules qui correspondent directement \`a l'axiome \textbf{read-over-write} :

\begin{enumerate}
\item $select(a',i)=e$ pour la valeur qui est \'ecrite,
\item $\forall j\neq i. select(a',j)=select(a,j)$ pour les valeurs qui sont inchang\'ees.
\end{enumerate}	
	
On l'appelle la r\'egle d'\'ecriture. Elle est une transformation \'equivalente dans les formules des tableaux logiques.

Maintenant, la logique des tableaux peut \^etre r\'eduite \`a la combinaison entre la logique des indices et les fonctions non-interpr\'et\'ees. La combinaison de l'arithm\'etique de Presburger et des fonctions non-interpr\'et\'ees est ind\'ecidable. Or, dans un programme, les indices d'un tableau sont des entiers. Il est donc int\'eressant de conna\^itre la restriction n\'ecessaire de l'ensemble des formules.

	
	D\'efinissons maintenant une classe r\'eduite des formules de la logique des tableaux pour obtenir la d\'ecidabilit\'e. Nous consid\'erons les formules qui sont des combinaisons bool\'eennes de \textbf{propri\'et\'es de tableau}.
	
	\begin{definition}
		(Propri\'et\'e de tableau). Une formule de la logique des tableaux est appel\'ee \textbf{propri\'et\'e de tableau} si et seulement si elle est de la forme :
		
$\forall i_{1},\ldots,i_{k}\in \sigma_I.\phi_{I}(i_{1},\ldots,i_{k})\Longrightarrow\phi_{V}(i_{1},\ldots,i_{k})$, et satisfait les conditions suivantes :
\begin{enumerate}
\item La fonction bool\'eenne $\phi_I$, appel\'ee \textbf{index guard}, doit suivre la grammaire suivante :

$\phi_I : \phi_I\land \phi_I$ $|$ $\phi_I\lor \phi_I$ $|$ $iterm\leq iterm$ $|$ $iterm = iterm$

$iterm :$ $i_{1}$ $|$ $\ldots$ $|$ $i_{k}$ $|$ $term$

$term :$ integer-constant $|$ integer-constant $\times$ index-identifier $|$ term+term

Le "index-identifier" utilis\'e dans "term" ne doit pas \^etre l'un des $i_{1}\ldots i_{k}$.
\item Les indices $i_{1}\ldots i_{k}$ ne peuvent \^etre utilis\'e que dans une expression de la forme $select(a,i_{j})$.
\end{enumerate}

La fonction bool\'eennes $\phi_{V}$ est appel\'ee \textbf{contrainte de valeur} et est restreinte par la deuxi\`eme r\`egle.
	\end{definition}
	Il existe un algorithme, que nous ne pr\'eciserons pas, acceptant le fragment des propri\'et\'es de tableau et le r\'eduisant \`a une formule \'equisatisfaisable qui utilise la th\'eorie des \'el\'ements et la th\'eorie des indices.
	
	Nous supposons que les op\'erations suivantes sont d\'efinies dans les th\'eories des indices et des \'el\'ements, et que nous avons une proc\'edure de d\'ecision pour la combinaison de th\'eories: 
	\begin{itemize}
	\item Pour la th\'eorie des indices, nous supposons que l'arithm\'etique lin\'eaire sur les indices est permise (celle de Presburger par exemple).
	\item Pour la th\'eorie des \'el\'ements, nous supposons seulement que l'\'egalit\'e entre deux \'el\'ements est permise.
	\end{itemize}

	
 	\subsection{Combinaison de th\'eories d\'ecidables}
 	Avant de parler de combinaison de th\'eories d\'ecidables, nous allons d\'efinir quelques notions.
 	\begin{definition}
 	(Combinaison de th\'eories).
 		Soit $T_{1}=(\Sigma_{1},M_{1})$ et $T_{2}=(\Sigma_{2},M_{2})$ deux th\'eories, la combinaison de th\'eories $T_{1} + T_{2}$ est une $(\Sigma_{1}\cup\Sigma_{2})$-th\'eorie d\'efinie par les ensembles $(M_{1}\cup M_{2})$.
	\end{definition}
	
	\begin{definition}
	(Probl\`eme de combinaison de th\'eorie). Soit $\phi$ une $(\Sigma_{1}\cup\Sigma_{2})$-formule. Le probl\`eme de combinaison de th\'eorie est de d\'ecider si $\phi$ est $T_{1}+T_{2}$-valide.
	\end{definition}
	
	La combinaison des th\'eories est, en g\'en\'eral, ind\'ecidable m\^eme si les th\'eories sont d\'ecidables. Ainsi, pour rendre les combinaisons d\'ecidables, il est n\'ecessaire de les restreindre.	La proc\'edure de Nelson-Oppen est une proc\'edure de d\'ecision pour la combinaison de th\'eories r\'epondant \`a des restrictions pr\'ecises. Nous n'allons pas aborder son fonctionnement mais seulement ses restrictions.
	\begin{definition}
		Pour que la proc\'edure de Nelson-Oppen soit applicable, les th\'eories $T_{1},\ldots,T_{n}$ doivent suivre les restrictions suivantes :
		\begin{enumerate}
		\item $T_{1},\ldots,T_{n}$ sont des th\'eories du premier ordre, sans quantificateur et avec l'\'egalit\'e.
		\item Il y a une proc\'edure de d\'ecision pour chaque th\'eorie $T_{1},\ldots,T_{n}$.
		\item Les signatures sont disjointes, c'est-\`a-dire, $\forall 1\leq i<j\leq n,$ $\Sigma_{i}\cap\Sigma_{j}=\emptyset$.
		\item $T_{1},\ldots,T_{n}$ sont des th\'eories qui sont interpr\'et\'ees sur un domaine infini.
		\end{enumerate}
	\end{definition}
	Il existe des extensions de la proc\'edure de Nelson-Oppen pouvant surmonter chacune des restrictions. Les techniques de combinaison de d\'ecision sont essentielles \`a la construction des SMT solveurs.

 	\subsection{SMT-solveur}
	 		Un SMT-solver permet de tester la validit\'e des formules logiques \`a l'aide de proc\'edures de d\'ecision. Nous allons discuter d'une m\'ethode g\'en\'erale sur laquelle se basent la plupart des SMT-solvers.
	 		
	 		 Soit $T=(\Sigma,M)$ une th\'eorie du premier ordre sans quantificateur et $DP_{T}$ une proc\'edure pour le fragment des conjonctions de $T$ ($DP_{T}$ peut d\'ecider une conjonction de $T$-lit\'eraux). La m\'ethode combine $DP_{T}$ avec un SAT-solveur (solveur de contraintes de la logique propositionnelle) de diverses mani\`eres afin de construire une proc\'edure de d\'ecision pour T. Cette approche a en pratique de gros avantages, car elle est tr\`es modulaire et tr\`es efficace. Les deux principaux outils de cette m\'ethode travaillent en collaboration : le SAT-solver choisit la valeur des litt\'eraux afin de satisfaire la structure bool\'eenne de la formule et $DP_{T}$ v\'erifie que le choix est $T$-satisfaisable.
	 		 
	 		Soit un $T$-litt\'eral $l$, nous lui associons une variable bool\'eenne unique $e(l)$, que nous appelons l'\textbf{encodeur} bool\'een de ce litt\'eral. \'Etendons l'id\'ee aux formules, soit une $T$-formule $\phi$, $e(\phi)$ correspond \`a la formule bool\'eenne o\`u chaque litt\'eral a \'et\'e substitu\'e par son encodeur bool\'een. $e(\phi)$ est appel\'ee le \textbf{squelette propositionnel} de $\phi$. En utilisant ces notations, nous allons \'etudier un aper\c{c}u de cette m\'ethode.
	 		
	 		Soit $T$ la th\'eorie de l'\'egalit\'e, une formule	$\phi :=$ $x=y$ $\land$ $((y=z\land x\neq z)\lor x=z)$.\\
	 		Nous transformons cette formule en son squelette propositionnel,
	 		
	 		 $e(\phi):= e(x=y)\land (e(y=z)\land e(x\neq z))\lor e(x=z)$.
	 		 
Soit $B$ une formule bool\'eenne, initialement $e(\phi)$. La seconde \'etape consiste \`a passer $B$ au SAT-solver. Supposons que le SAT-solver retourne l'\'evaluation satisfaisante\par
$\nu:=$ $\{e(x=y)\mapsto vrai, $ $e(y=z)\mapsto vrai,$ $e(x\neq z)\mapsto vrai,$ $e(x=z)\mapsto faux\}$.

La proc\'edure de d\'ecision $DP_{T}$ doit maintenant d\'ecider si la conjonction des litt\'eraux correspondant \`a cette \'evaluation est satisfaisable. Nous notons cette conjonction $Th(\alpha)$, $Th(\alpha):=$ $x=y\land y=z\land x\neq z\land \neg(x=z)$.
 
	Cette formule n'est pas satisfaisable donc sa n\'egation est valide. Ainsi, nous ajoutons $e(\neg Th(\alpha))$ \`a $B$, l'encodeur bool\'een de cette tautologie :
 $e(\neg Th(\alpha)) := (\neg e(x=y)\lor\neg e(y=z)\lor\neg e(x\neq z)\lor e(x=z))$.
 
Cette formule est contradictoire \`a l'\'evaluation pr\'ec\'edente et donc emp\^eche le SAT-solver de se r\'ep\'eter. Apr\`es avoir ajout\'e la nouvelle clause, le SAT-solver est de nouveau appel\'e et sugg\`ere une autre affectation :
$\nu:=$ $\{e(x=y)\mapsto vrai, $ $e(y=z)\mapsto vrai,$ $e(x\neq z)\mapsto faux,$ $e(x=z)\mapsto vrai\}$.

La $T$-formule suivante,

 $Th(\alpha ' ):=$ $x=y\land y=z\land x=z\land \neg(x\neq z)$
 
est satisfaisable, ce qui prouve que $\phi$, la formule originelle, est satisfaisable.


\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

\draw    (164.8, 142.73) circle [x radius= 64.8, y radius= 33.73]  ;
\draw    (504.8, 141.73) circle [x radius= 64.8, y radius= 33.73]  ;
\draw    (224,127) -- (444.6,127.47) ;
\draw [shift={(444.6,127.47)}, rotate = 180.12] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ]   (0,0) .. controls (3.31,-0.3) and (6.95,-1.4) .. (10.93,-3.29)(0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

\draw    (450,160) -- (222.6,159.47) ;
\draw [shift={(222.6,159.47)}, rotate = 360.13] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ]   (0,0) .. controls (3.31,-0.3) and (6.95,-1.4) .. (10.93,-3.29)(0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;


\draw (507,145) node  [align=left] {Proc\'edure\\ de d\'ecision};
\draw (165,140) node  [align=left] {SAT-solver};
\draw (256,113) node   {$\alpha $};
\draw (408,115) node   {$Th( \alpha )$};
\draw (251,172) node   {$e( t)$};
\draw (429,172) node   {$t$};


\end{tikzpicture}
\section{V\'erification d\'eductive avec \verifast{}}
	La v\'erification d\'eductive se base sur l'annotation des programmes. Chaque fonction est v\'erifi\'ee s\'epar\'ement, en utilisant les contrats des autres fonctions et non leurs impl\'ementations. Le contrat d'une fonction consiste en une pr\'econdition et une postcondition. La pr\'econdition sp\'ecifie les attentes, concernant le tas et la pile, au d\'ebut de la fonction. La postcondition sp\'ecifie les garanties offertes, concernant la pile et le tas, \`a la sortie de la fonction.
	\subsection{Programme}
		\verifast{} permet la v\'erification des programmes C et Java. La s\'emantique d'un programme peut \^etre donn\'ee par l'ensemble de ses ex\'ecutions. Une ex\'ecution est d\'efinie par une s\'equence fini ou infini de configurations, chacune li\'ee \`a l'autre par une instruction du programme. Une configuration est un \'etat et une continuation. Un \'etat est une pile et un tas. La pile sp\'ecifie la valeur des variables du programme. Le tas sp\'ecifie la valeur des cellules de m\'emoire. La continuation pr\'ecise ce qu'il va se passer ensuite. Une continuation est soit \textit{une continuation d'instructions}, soit une \textit{fin de fonction}, soit une \textit{fin de programme}.\\
	Dans un programme, toutes les variables pr\'ec\'edement d\'efinies doivent toujours avoir une valeur dans la pile et chaque espace m\'emoire doit \^etre r\'epr\'esent\'e dans le tas. Pour repr\'esenter le tas, \verifast{} utilise la logique de s\'eparation.
	\subsection{Logique de s\'eparation}
		\subsubsection{Syntaxe}
	La syntaxe de la logique de s\'eparation (SL)\cite{OHearnRY01} est construite sur la syntaxe de la logique du premier ordre, d\'efinie \`a la subsection 1.1.1. Nous consid\'erons une th\'eorie du premier ordre $T=(\Sigma,M)$ telle que $\Sigma^{s}$ contient les types $Loc$ et $Data$ et $\Sigma^{f}$ contient une constante $nil^{Loc}$.
	\begin{definition}
	(Formule de la logique de s\'eparation). Une formule SL s'\'ecrit avec les m\^emes r\`egles qu'une formule du premier ordre en ajoutant ces r\`egles :
	
	\begin{tabular}{lclcl}
		$\phi^{SL}$ & $ ::= $ & $\ldots$ & \\
		& $|$ & emp & & (tas vide)\\
		& $|$ & $t\mapsto u,$ & $t^{Loc},u^{Data}$ & (tas singleton)\\
		& $|$ & $\phi_{1}^{SL} * \phi_{2}^{SL},$ & & (conjonction de s\'eparation)
	\end{tabular}
	\end{definition}
	
	Les deux nouveaux atomes d\'ecrivant le tas vide et le tas singleton sont des formules SL($T$).
	
	Si une SL($T$)-formule contient au moins une fois emp, $\mapsto$ ou $*$ alors c'est une formule \textit{spatiale} sinon c'est une formule \textit{pure}.
	
	La plupart des d\'efinitions de structure de donn\'ees, telles que les listes ou les arbres, utilisent un fragment restreint sans quantificateur appel\'e \textit{tas symbolique}.
\begin{definition}
(Formule de tas symbolique). Une formule de \textit{tas symbolique} est une conjonction $\Pi\land\Theta$ entre une partie pure $(\Pi)$ et une partie spatiale $(\Theta)$, d\'efinie ainsi :\\
\begin{tabular}{lclcl}
$\Pi$ & $::=$ & $\top$ & &(vrai)\\
& $|$ & $\bot$ & &(faux)\\
& $|$ & $t,$ & $t^{Bool}$  & (terme bool\'een)\\
& $|$ & $t_{1}\approx t_{2},$ & $t^{Loc}_{1},t^{Loc}_{2}$ & (egalit\'e)\\
& $|$ & $\neg(t_{1}\approx t_{2}),$ & $t^{Loc}_{1},t^{Loc}_{2}$ & (inegalit\'e)\\
& $|$ & $\Pi_{1}\land\Pi_{2},$& &(conjonction)\\
$\Theta$ & $::=$ & emp & &(tas vide)\\
& $|$ & $t\mapsto u,$ & $t^{Loc},u^{Data}$ & (tas singleton)\\
& $|$ & $\Theta_{1}*\Theta_{2},$ & & (conjonction de s\'eparation)
\end{tabular}

\end{definition}

		\subsubsection{S\'emantique}
	\begin{definition}
	(Tas).Soit une interpr\'etation $I$, le tas est une partie finie associant une location avec une donn\'ee, $h : Loc^{I} \rightarrow_{fin} Data^{I}$. Nous utiliserons $Tas^{I}$ pour repr\'esenter l'ensemble de tous les tas sous l'interpr\'etation de $I$.
	\end{definition}
	Deux tas $h_{1}$ et $h_{2}$ sont disjoints si dom($h_{1}$)$\cap$dom($h_{2}$) $= \emptyset$. L'union disjointe sera symbolis\'ee par $h_{1}\cupdot h_{2}$ qui est ind\'efinie si $h_{1}$ et $h_{2}$ ne sont pas disjoints. Nous \'ecrivons $\bigcupdot H$ pour l'union disjointe des tas dans l'ensemble $H \subseteq Tas$.
	\begin{definition}
	(S\'emantique des formules de la logique de s\'eparation). Soit une interpr\'etation $I$, une \'evaluation $\nu\in V_{I}$ et un tas $h\in Tas$, nous \'ecrivons $I,\nu,h\models^{SL}\phi$ si une formule SL $\phi$ est interpr\'et\'ee \`a vrai sous $I,\nu$ et $h$. Cette relation est d\'efinie par induction  dans la structure de $\phi$ :
	
\begin{tabular}{ll}
$I,\nu,h\models^{SL}$emp & ssi dom($h$)=$\emptyset$\\
$I,\nu,h\models^{SL}t\mapsto u$ & ssi $t^{I}_{\nu}\neq nil^{I}$ et $h = \{(t^{I}_{\nu},u^{I}_{\nu} )\}, t^{Loc}, u^{Data}$\\
$I,\nu,h\models^{SL}\phi_{1}*\phi_{2}$ & ssi $\exists h_{1}\exists h_{2}.h=h_{1}\cupdot h_{2}$ et $I,\nu,h_{1}\models^{SL}\phi_{1}$ et $I,\nu,h_{2}\models^{SL}\phi_{2}$
\end{tabular}

	\end{definition}
	Un triplet $(I,\nu,h)$ tel que $(I,\nu)\in M$ et $I,\nu,h\models^{SL}\phi$ est un SL($T$)-mod\`ele pour la SL($T$)-formule $\phi$. Nous noterons l'ensemble des SL($T$)-mod\`eles de $\phi$ par $\phibra_{SL(T)} = \{(I,\nu,h)|(I,\nu)\in M,h\in Tas^{I}$ et $I,\nu,h\models^{SL}\phi\}$.

La logique de s\'eparation ajoute la r\`egle du cadre \`a la logique de Hoare :
		\begin{center}
		

\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt        

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

\draw    (248.6,122.47) -- (355.6,122.47) ;



\draw (302,112) node  [align=left] {\{P\}C\{Q\}};
\draw (301,133) node  [align=left] {\{P * R\}C\{Q * R\}};

\end{tikzpicture}
		\end{center}
, o\`u R est une formule qui ne concerne pas les variables utilis\'ees par C.

		Informellement, la r\`egle dit que la preuve de $C$ peut ignorer la partie du tas ne con\c{c}ernant pas $C$.
		
	\subsection{Annotations et assertions}
		 En \verifast, les annotations sont exprim\'ees sous forme d'\textit{assertions}. Les assertions sont des formules de la logique de s\'eparation.
		 
		\begin{exemple}
		Exemple : Soit une fonction r,
		\begin{lstlisting}
		int exemple(int a,int b)
		 //@ requires a = b;
		 //@ ensures result = 0;
		{ return a-b;}
		\end{lstlisting}
		\end{exemple}
		
	
		La pr\'econdition de l'\textit{exemple} assure que l'\'egalit\'e entre a et b est respect\'ee. La postcondition de \textit{exemple} assure que la valeur retourn\'ee par le programme est 0, en supposant que la pr\'econdition est respect\'ee. 
	
	L'une des notions de base de la v\'erification d\'eductive est les pr\'edicats. En effet, le contrat des fonctions doit pouvoir \^etre exprim\'e pour les tas de taille quelconque, de mani\`ere symbolique. Un pr\'edicat est simplement une formule. La d\'efinition d'un pr\'edicat est de la forme
	\begin{center}
	
		\textbf{predicate} $p(x_1,\ldots,x_n):=a$

	\end{center}
o\`u $p$ est le nom du pr\'edicat, $x_1,\ldots,x_n$ sont les noms des variables et $a$ une formule. $x_1,\ldots,x_n$ sont appel\'ees les param\`etres de $p$ et $a$ le corps de $p$.

	En utilisant les pr\'edicats, un tas symbolique peut \^etre d\'eriv\'e depuis un tas concret. Un tas symbolique ne contient pas de cellules de m\'emoire mais des instances de pr\'edicats. Un tas symbolique est obtenu depuis un tas concret en fermant des instances de pr\'edicats. La fermeture d'une instance de pr\'edicat, \textit{close}, remplace la partie du tas d\'ecrite par le corps de l'instance du pr\'edicat par l'instance du pr\'edicat elle-m\^eme. Inversement, l'ouverture d'une instance de pr\'edicat, \textit{open}, remplace l'occurence du pr\'edicat avec un fragment du tas correspondant au corps du pr\'edicat. Nous disons qu'un tas symbolique fait abstraction d'un tas concret si le tas concret peut \^etre obtenu \`a travers un nombre fini d'op\'erations \textit{open}.
	
	Les instructions \textit{open} et \textit{close} sont les \textit{instructions fant\^omes}. Nous appelons l'effacement d'un programme annot\'e, le fait, de supprimer toutes les annotations d'un programme.
	\begin{exemple}
		\begin{lstlisting}
		
		predicate equal(x,y) := x=y
		
		int exemple'(int a, int b)
		//@ requires equal(a,b);
		//@ ensures equal(result,0);
		{
		//@ open equal(a,b);
		return a-b;
		//@ close equal(result,0);
		}
		\end{lstlisting}
	\end{exemple}
	Nous allons aborder les notions de consommation et de production d'assertion. 
		\subsubsection{S\'emantique des assertions}
	Les assertions sont interpr\'et\'ees par rapport \`a un tas symbolique.
	Appelons points-to assertion, l'assertion repr\'esentant la formule \textit{tas singleton} (voir SL). Nous d\'efinissons l'ensemble des \'el\'ements du tas symbolique comme l'union des \'el\'ements points-to et des instances de pr\'edicat :
	
	$AbsHeapElems$ $= \{l\mapsto v| l\in Addresses, v\in \mathbb{Z}\}\cup\{p(v_1,\ldots, v_n)|v_1,\ldots,v_n\in\mathbb{Z}\}$
	
	Nous d\'efinissons un \'etat symbolique comme un triplet d'une pile, d'un tas symbolique et d'un chemin de conditions.
			
		
	\subsection{Logique de sp\'ecification en \verifast{}}
	
		Une notion, que nous n'avons pas abord\'ee, et qui est primordiale dans la logique de sp\'ecification de \verifast, est l'invariant de boucle. L'invariant de boucle est une formule qui est vraie avant, pendant et apr\`es la boucle. Il permet donc d'assurer que le code est correct pendant et apr\`es la boucle. Nous allons maintenant voir les annotations plus complexes, dont nous n'avons pas encore parl\'ees, dans \verifast.
			\paragraph{Types et predicats inductifs}
		
				Pour permettre des sp\'ecifications riches, \verifast{} supporte les types inductifs. Les types inductifs permettent \`a \verifast{} de repr\'esenter des structures inductives. Souvent, chaque \'el\'ement de la structure doit respecter certaines propri\'et\'es. Par exemple, dans une pile, chaque \'el\'ement doit avoir un espace allou\'e.	Pour repr\'esenter ces conditions, on utilise des pr\'edicats inductifs.\\ Dans l'exemple suivant, le type \textit{ints} repr\'esente la liste des \'el\'ements dans la pile. Le pr\'edicat \textit{nodes} indique que de l'espace allou\'e pour chaque \'el\'ement et que les \'el\'ements de \textit{ints} correspondent bien aux \'el\'ements de la pile.
				
			
			\begin{lstlisting}
struct node {
	struct node *next;
	int value;
};
				
inductive ints = ints_nil | ints_cons(int, ints);

predicate nodes(struct node *node, ints num) =
	node == 0 ?
	num == ints_nil :
	num == ints_cons(?number,?num2) 
	&*& node -> next |-> ?n &*& node->value |-> number
	&*& malloc_block_node(node) &*& nodes(n,num2);

	
			\end{lstlisting}
			
			La notation \&*\& permet de simplifier * qui joue le r\^ole de la conjonction ($\land$).			
			\paragraph{Fixpoints}
				En plus des types inductifs, \verifast{} permet aussi les fixpoints. Un fixpoint est une fonction avec au moins un argument de type inductif. Le corps du fixpoint doit \^etre un \textbf{switch} sur l'un de ses arguments inductifs. Pour s'assurer que les fixpoints sont bien d\'efinis, le corps d'un fixpoint $f$ peut utiliser un autre fixpoint $g$ seulement si $g$ appara\^it avant $f$ dans le programme. Si f est r\'ecursif,l'une des composantes d'un argument inductif de $f$ doit \^etre utilis\'ee \`a la place de cet argument. Par exemple, le fixpoint ci-dessous indique la longueur d'un \'el\'ement de type \textit{ints}.
			\begin{lstlisting}
fixpoint int length(ints l){
 switch(l) {
  case ints_nil : return 0;
  case cons(h,t) : return 1 + length(t);
 }
}
			\end{lstlisting}
			\paragraph{Lemmes}
			\verifast{} a en r\'ealit\'e une instruction suppl\'ementaire pour le code fant\^ome, en plus des \textit{open} et \textit{close}. En effet, il est possible d'appeler des lemmes. Comme un fonction C, un lemme prend des arguments, \`a une pr\'econdition et une postcondition. Le corps d'un lemme repr\'esente une preuve. Cette preuve du lemme d\'emontre que la pr\'econdition implique la postcondition pour toutes les valeurs possibles des arguments. L'appel d'un lemme correspond donc \`a l'application d'un th\'eor\`eme.
			
			Pour que la preuve soit valide, le corps doit satisfaire certaines restrictions. Dans un premier temps, le corps ne doit pas affecter l'\'etat concret, plus pr\'ecisement, il ne doit pas modifier de champs ou appeler des fonctions C. Deuxi\`emement, l'ex\'ecution du corps doit terminer. Pour assurer la terminaison, les boucles et les appels de lemmes sont limit\'es. \\
			Les boucles doivent avoir un variant. Un variant de boucle doit strictement d\'ecroitre  \`a chaque tour de boucle et doit \^etre d\'efini dans un ensemble bien fond\'e.\\
			Un lemme $x$ peut appeler un lemme $y$ s'il est d\'efini avant dans le programme ou si l'appel est r\'ecursif. Si l'appel est r\'ecursif, alors l'une des restrictions suivantes doit \^etre respect\'ee :
			\begin{enumerate}
			\item L'appel r\'ecursif r\'eduit la taille du tas. Plus pr\'ecisement, apr\`es la consommation des pr\'econditions d'un appel r\'ecursif, il doit rester un champ dans le tas.
			\item L'appel r\'ecursif r\'eduit le type d'un argument inductif. Le corps du lemme est alors un \textbf{switch} sur un argument inductif et l'un des param\`etres de l'argument est utilis\'e \`a la place de l'argument inductif dans l'appel r\'ecursif.
			\item L'appel r\'ecursif r\'eduit la profondeur de la premi\`ere conjonction de la pr\'econdition. Plus pr\'ecisement, le corps du lemme n'est pas un switch et la consommation du premier pr\'edicat dans la pr\'econdition de l'appel r\'ecursif est obtenue en ouvrant le premier pr\'edicat produit par la pr\'econdition du lemme.
			\end{enumerate}
				

	\subsection{Preuve de programme}
	
	\paragraph{Consommation d'une assertion}
			Dans un \'etat symbolique, consommer une assertion, revient \`a v\'erifier qu'il existe un fragment de tas qui correspond \`a l'assertion et de supprimer le fragment du tas. La consommation effectue un filtrage.
	
	Une points-to assertion et un pr\'edicat peuvent contenir des motifs de variables de la forme $?x$. Un motif de variable correspond \`a n'importe quelle valeur et associe la valeur \`a la variable.
	
	D\'efinissons la fonction \textit{consume}, $consume(s,H,\Pi,a,Q)$ indique que la consommation de l'assertion $a$ dans un \'etat symbolique $(s,H,\Pi)$ r\'eussit, et que le prochain \'etat satisfait la consommation de la postcondition $Q$.
	
	Pour la consommation des points-to et des pr\'edicats, la fonction $consume$ a deux fonctions auxiliaires, $match$_$pattern$ et $match$_$patterns$.\\ $match$_$pattern(s,v,\pi)$ tente de faire correspondre la valeur $v$ au motif $\pi$ dans la pile $s$. Si le filtrage r\'eussit, la fonction retourne un singleton contenant la pile r\'esultante, c'est-\`a-dire, la pile $s$ apr\`es avoir associ\'ee la valeur $v$ \`a $\pi$. Sinon, elle retourne l'ensemble vide.\\
	De la m\^eme fa\c{c}on, la fonction $match$_$patterns(s,\bar{v},\bar{\pi}$) tente de faire correspondre une liste de valeur $\bar{v}$ et une liste de motifs $\bar{\pi}$. Si le filtrage r\'eussit, la fonction retourne un singleton contenant la pile r\'esultante, c'est-\`a-dire, la pile $s$ apr\`es avoir associ\'ee la liste de valeurs $\bar{v}$ \`a la liste de motifs $\bar{\pi}$. Sinon, elle retourne l'ensemble vide.
	
	Nous avons les propri\'et\'es suivantes :	
	
	\begin{lemme}
		(Affaiblissement de la postcondition de consommation). Si la consommation d'une assertion par rapport \`a une certaine postcondition  r\'eussit, alors la consommation par rapport \`a une postcondition plus faible r\'eussit aussi.
		
$\forall s,H,a,Q,Q'$ $consume(s,H,a,Q)\Rightarrow\\(\forall s', H'$ $Q(s',H')\Rightarrow Q'(s',H'))\Rightarrow consume(s,H,a,Q')$
	\end{lemme}
	
	\begin{lemme}
		(Encadrement de la consommation). Si la consommation d'une assertion r\'eussit, alors elle r\'eussit lorsque des \'el\'ements sont ajout\'es au tas symbolique, que ces \'el\'ements sont toujours pr\'esents dans chaque post-\'etat et la postcondition d'origine est conserv\'ee apr\`es avoir supprim\'es les \'el\'ements ajout\'es.
	\end{lemme}
	Nous disons qu'un \'etat symbolique satisfait une assertion si la consommation de l'assertion dans l'\'etat symbolique r\'eussit et le tas symbolique r\'esultant est vide.\\
	
	\begin{lemme}
		(Consommation correcte). Si la consommation d'une assertion r\'eussit dans un \'etat symbolique, alors le tas symbolique peut \^etre s\'epar\'e en un fragment qui satisfait l'assertion et un fragment qui satisfait la postcondition.
	\end{lemme}
			\paragraph{Production d'une assertion}
		L'op\'erateur de production d'assertion est l'inverse de celui de consommation: produire une assertion dans un \'etat symbolique donn\'e \'etend le tas avec un fragment arbitraire de tas satisfaisant l'assertion.\\
		Plus pr\'ecisement, la fonction $produce(s,H,\Pi,a,Q)$ signifie que la postcondition $Q$ est valable  dans tous les \'etats obtenus en \'etendant l'\'etat symbolique $(s, H, \Pi)$ avec un fragment de tas qui satisfait l'assertion $a$.
		
		La fonction auxiliaire $produce$_$pattern(s,\pi,Q)$ signifie que la postcondition $Q$ est valable pour chaque pair $(s',v)$ telle que la valeur $v$ filtre avec le motif $\pi$ dans la pile $s$ et $s'$ est $s$ mise \`a jour avec le motif appropri\'e.
		
		\begin{lemme}
			(Affaiblissement de la postcondition de production). Si la production d'une assertion r\'eussit, alors la production r\'eussit aussi avec une postcondition plus faible.
			
$\forall s,H,a,Q,Q'$ $produce(s,H,a,Q)\Rightarrow\\(\forall s', H'$ $Q(s',H')\Rightarrow Q'(s',H'))\Rightarrow produce(s,H,a,Q')$
		\end{lemme}	
		
		\begin{lemme}
		(Production Tas Inutile). Produire une assertion dans un \'etat symbolique $E = (s,H,\Pi)$  est \'equivalent \`a produire la m\^eme assertion dans un tas vide et d'ajouter le tas $H$ au tas post-\'etat.
		\end{lemme}
	
		\begin{lemme}
		(Production correcte). Si un \'etat symbolique $E=(s,H,\Pi)$ satisfait une assertion et que la production de cette assertion r\'eussit dans un tas vide, alors la postcondition de la production est valable dans le tas $H$.
		\end{lemme}
		
	\verifast{} v\'erifie si un programme satisfait sa sp\'ecification avec des ex\'ecutions symboliques et en utilisant un SMT-solver. Nous allons d\'efinir une ex\'ecution symbolique.
	
	Les r\`egles d'une \textbf{ex\'ecution symbolique} sont d\'efinies par \textit{continuation passing style}. La continuation $Q$ repr\'esente le travail qu'il reste \`a faire sur le chemin actuel. Par soucis de bri\`evet\'e, seulement une partie des r\`egles est pr\'esent\'ee.
	
	Produire une assertion points-to revient \`a ajouter un fragment avec un nouveau symbole au tas et \`a lier le symbole \`a la variable.
	\begin{center}
		$produce(s,H,\Pi,f\mapsto?x,Q)\equiv$\\
		let $\sigma=fresh(s,H,\Pi)$ in $Q(s[x:=\sigma],h\cupdot\{(f,\sigma)\},\Pi)$
	\end{center}
	Produire une assertion pure, telle que $e_1 = e_2$, revient \`a ajouter une formule \'equivalente au chemin de conditions.
	\begin{center}
		$produce(s,H,\Pi,e_1 = e_2,Q)\equiv\Pi\not\vdash_{SMT}\neg\llbracket e_1 = e_2\rrbracket\rightarrow Q(s,H,\Pi\cup\{\llbracket e_1 = e_2\rrbracket_s\})$
	\end{center}
	Produire une assertion conditionnelle revient \`a cr\'eer deux branches dans l'ex\'ecution symbolique. L'une o\`u l'assertion est ajout\'ee et une autre o\`u sa n\'egation est ajout\'ee. Nous noterons qu'une branche n'est pas atteignable si le chemin de conditions est incoh\'erent.
	\begin{center}
		$produce(s,H,\Pi,e_1 = e_2?A_1:A_2,Q)\equiv$\\
		$(\Pi\not\vdash_{SMT}\neg\llbracket e_1 = e_2\rrbracket\rightarrow produce(s,H,\Pi\cup\{\llbracket e_1 = e_2\rrbracket_s\},A_1,Q))\land$\\
		$(\Pi\not\vdash_{SMT}\llbracket e_1 = e_2\rrbracket\rightarrow produce(s,H,\Pi\cup\{\neg\llbracket e_1 = e_2\rrbracket_s\},A_2,Q))$
	\end{center}
	Produire deux ensembles d'assertions s\'epar\'ees par la conjonction de s\'eparation revient \`a ajouter l'un puis l'autre.
	\begin{center}
		$produce(s,H,\Pi,A_1*A_2,Q)\equiv$\\
		$produce(s,H,\Pi,A_1,(\lambda h,s,\Pi.$ $produce(s,H,\Pi,A_2,Q)))$
	\end{center}
	
	Les r\`egles de consommation sont inverses.\\
	$consume(s,H,\Pi,f\mapsto?x,Q)\equiv$
	
	$\exists t_1,h'. h = \{(f,t_1)\}\cupdot h'\land \Pi\vdash_{SMT} Q(h',s[x:=t_1],\Pi)$\\ \\
		$consume(s,H,\Pi,e_1=e_2,Q)\equiv\Pi\vdash_{SMT}\llbracket e_1=e_2\rrbracket_s\land Q(s,H,\Pi)$\\ \\
		$consume(s,H,\Pi,e_1=e_2?A_1:A_2,Q)\equiv$ 
		
		$(\Pi\not\vdash_{SMT}\neg\llbracket e_1 = e_2\rrbracket\rightarrow consume(s,H,\Pi\cup\{\llbracket e_1 = e_2\rrbracket_s\},A_1,Q))\land$
		
		$(\Pi\not\vdash_{SMT}\llbracket e_1 = e_2\rrbracket\rightarrow consume(s,H,\Pi\cup\{\neg\llbracket e_1 = e_2\rrbracket_s\},A_2,Q))$\\ \\
		$consume(s,H,\Pi,A_1*A_2,Q)\equiv$
		
		$consume(s,H,\Pi,A_1,(\lambda h,s,\Pi.$ $consume(s,H,\Pi,A_2,Q)))$

	\`A chaque appel de fonction, les pr\'econditions doivent pouvoir \^etre consomm\'ees et les postconditions produites. Une fonction est valide si apr\`es avoir produit les pr\'econditions avec des valeurs arbitraires pour les param\`etres des fonctions et ex\'ecuter symboliquement le corps de la fonction, la postcondition peut \^etre consomm\'ee. La continuation finale assure l'absence de fuite de m\'emoire en v\'erifiant que la pile est vide apr\`es avoir consomm\'ee la postcondition. Un programme est valide si toutes les fonctions sont valides.
	
\section{Contributions}
	\subsection{Automatisation de la th\'eorie des tableaux}
	L'objectif de l'impl\'ementation est d'int\'egrer les fonctions de la th\'eorie des tableaux dans \verifast{} pour qu'elles soient directement retransmises \`a Z3.
	
	L'int\'er\^et d'automatiser la th\'eorie des tableaux est de faciliter la manipulation des tableaux mais aussi de faciliter le raisonnement sur d'autres types alg\'ebriques tels que les ensembles et les multi-ensembles.
	
	Les fonctions de la th\'eorie des tableaux manipulent un type tableau qui \'etait absent dans la logique de \verifast{}. En effet, la logique de sp\'ecification de \verifast{} ne poss\`ede pas de type tableau et la logique du premier ordre de \verifast{} permettant la communication avec Z3 est construite sur 4 types, les types int, bool\'een, r\'eel et \textit{inductive}.\\
	Le type inductive repr\'esente plusieurs types dont les types g\'en\'eriques. Par cons\'equent, il existe des fonctions de \textit{boxing} et d'\textit{unboxing}. Les fonctions de boxing permettent aux \'el\'ements d'un type diff\'erent d'\textit{inductive} d'\^etre utilis\'es dans des fonctions g\'en\'eriques en \'etant tranform\'es en type \textit{inductive}. Par exemple, \textit{mk_boxed_int} transforme un \'el\'ement de type int en un \'el\'ement de type \textit{inductive}. Le type de \textit{mk_boxed_int} est alors $int \rightarrow inductive$. Une fonction d'\textit{unboxing} permet de transformer un \'el\'ement du type \textit{inductive} vers un \'el\'ement d'un autre type $\sigma$. Le type de la fonction d'unboxing est $inductive \rightarrow \sigma$. Une propri\'et\'e sur ces fonctions est qu'unbox un \'el\'ement box\'e redonne le m\^eme \'el\'ement si les deux fonctions manipulent le m\^eme type :
	\begin{center}
		$mk\_unboxed\_int(mk\_boxed\_int(2)) = 2$
	\end{center}
	Attention, si $i$ est de type \textit{inductive}, $box(unbox(i))$ ne redonne pas forc\'ement $i$, m\^eme si les fonctions de boxing/unboxing manipulent le m\^eme type. La raison est que le type doit \^etre infini.
	 
	La premi\`ere \'etape du travail du TRE a donc \'et\'e d'ajouter un type primitif array dans la logique de sp\'ecification de \verifast{}. Il a ensuite fallu ajouter un type array dans les communications avec Z3 et pour finir, ajouter les fonctions de la th\'eorie des tableaux dans la logique de sp\'ecification mais aussi dans la logique de premier ordre afin de pouvoir transmettre le type array \`a Z3.
		\subsubsection{Ajout du type array}
		Soit $\sigma_A$ le type d'un tableau, la syntaxe de $\sigma_A$ dans \verifast{} est "array$(\sigma_I$,$\sigma_E)$". Par exemple, pour d\'efinir un tableau $a$ des entiers vers les bool\'eens, nous \'ecrivons $array(int,bool)$ $a$. Nous allons maintenant parler de la g\'en\'ericit\'e des tableaux dans \verifast{}, des contraintes pour pr\'eserver la coh\'erence de la th\'eorie et nous finirons par l'ajout du type tableau \`a la logique de premier ordre.
			\paragraph{G\'en\'ericit\'e}
			En logique de sp\'ecification, le type des indices et le type des \'el\'ements du type tableau sont deux types g\'en\'eriques. Cela signifie qu'ils peuvent \^etre de n'importe quel type. Un des objectifs a donc \'et\'e d'impl\'ementer un type tableau tout aussi g\'en\'erique. Le type et les fonctions ont \'et\'e implement\'ees ainsi mais \verifast{} a pos\'e une limite. Il n'y a pas de fonction g\'en\'erique dans \verifast, pour repr\'esenter les pointeurs. En effet, il y a seulement des fonctions "integer(int*,int)", "character(char*,char)", etc\ldots qui repr\'esentent des pointeurs d'un type pr\'ecis, respectivement int et char. Il n'est donc pas possible actuellement de compl\'eter la biblioth\`eque des tableaux avec uniquement des lemmes et pr\'edicats g\'en\'eriques. Il est, par exemple, impossible de dire qu'un tableau est bien d\'efini g\'en\'eriquement. La fonction array\_model, ci-dessous, indique que le tableau d'entiers $a$ est bien d\'efini entre $(a+b)$ et $(a+e)$ si un entier est bien d\'efini en $(a+b)$ et qu'un tableau est bien d\'efini entre $(a+b+1)$ et $(a+e)$.
\begin{lstlisting}
predicate array_model (int* a, int b, int e, array(int,int) arr) =
 (b >= e) ? true : (integer(a+b,?v) &*& select(arr, b) == v
 &*& array_model(a, b+1, e, arr));
\end{lstlisting}
			\paragraph{Limite du domaine}
			Un axiome assez naturel que des utilisateurs de \verifast{} pourraient vouloir ajouter est que $\forall f\in \sigma_I \rightarrow \sigma_E$, $\exists a\in \sigma_A$ tel que $\forall i\in I, f(i) = select(a,i)$.
		Or, l'axiome n'est pas compatible avec un type t \'equivalent \`a array(t,p), p \'etant un type quelconque. Il est par cons\'equent interdit de d\'efinir un type \textit{inductive} $t$ avec un param\`etre de type tableau ayant $t$ comme type du domaine. Par exemple, la d\'efinition suivante est interdite :
			\begin{lstlisting}			
    inductive t = mk_array (array(t,int));
			\end{lstlisting}
			\paragraph{Type habit\'e}
				Dans \verifast{}, tous les types doivent \^etre habit\'es, c'est-\`a-dire, tous les types doivent avoir au moins un \'el\'ement. En effet, il existe cet axiome dans \verifast{} :
		\begin{lstlisting}
		fixpoint t default_value<t>();
		\end{lstlisting}
		Cet axiome retourne un \'el\'ement du type t. Donc s'il existe un type non-habit\'e alors le syst\`eme n'est plus coh\'erent.
		
		Par exemple, avec le type stream ci-dessous :
\begin{lstlisting}
inductive stream = Cons (int, stream);
\end{lstlisting}
Il est possible de prouver le faux avec ces deux fonctions :
\begin{lstlisting}
lemma void no_stream (stream x)
	//@ requires true;
	//@ ensures false;
	{ switch (x) : {
		case Cons(_,s) { no_stream(s); }
	}

lemma void absurd()
	//@ requires true
	//@ ensures false
	{ no_stream(default_value<stream>())}

		\end{lstlisting}

De plus, l'implication
				$\forall x. P(x) \rightarrow \exists x. P(x)$ est utilis\'ee dans la logique de \verifast{} et n'est vraie que si le type de $x$ est habit\'e.
				
				Pour \'eviter la cr\'eation d'un type non-habit\'e \`a l'aide des tableaux, il a \'et\'e interdit de cr\'eer un type inductif $t$ ayant uniquement comme param\`etre des tableaux utilisant $t$ pour le type des indices ou des \'el\'ements. Par exemple, ci-dessous, la premi\`ere version du type t a \'et\'e interdite car le type est non-habit\'e. La deuxi\`eme est autoris\'ee car empty est un \'el\'ement de type t. :
				\begin{lstlisting}			
   1. inductive t = mk_array (array(int,t));
   2. inductive t = mk_array (array(int,t))| empty;
				\end{lstlisting}
				
			\paragraph{Type infini}
				\verifast{} a besoin de savoir si un type est de taille infinie. Si un type est infini, il est au moins aussi grand que le type \textit{inductive}. Une fonction $f$ de boxing et une fonction $g$ d'unboxing manipulant un m\^eme type infini sont inverses dans les deux sens, c'est-\`a-dire, $g\circ f = id$ et $f\circ g = id$, o\`u $id$ est la fonction identit\'e. Si le type est fini, alors $f\circ g\neq id$. En effet, si $f$ et $g$ manipulent un type fini et que $f\circ g = id$ alors \verifast{} deviendrait incoh\'erent.
				
		Posons $b_b$ et $u_b$ les fonctions de boxing et d'unboxing du type bool\'een, $b_i$ et $u_i$ les fonctions de boxing et d'unboxing du type int. Nous avons alors $u_i \circ b_i = id$, $b_i\circ u_i=id$ et $u_b\circ i_b=id$ car int est un type infini. Supposons que $b_b\circ u_b=id$ alors que le type bool\'een est fini,
		
		$\begin{array}{lccccll}
		
		u_b(b_i(0)) & = & vrai & \lor & u_b(b_i(0))& = & faux$ par definition du type bool\'een$ \\
		b_b(u_b(b_i(0))) & = & b_b(vrai)& \lor & b_b(u_b(b_i(0))) & = & b_b(faux)\\
		b_i(0) & = & b_b(vrai)& \lor & b_i(0) & = & b_b(faux)$ par supposition$
		\end{array}$\\
		
		
		Si l'on r\'ep\`ete les m\^emes op\'erations avec 1 et 2. On obtient le syst\`eme suivant :
$\begin{cases} b_i(0) = b_b(vrai) \lor b_i(0) = b_b(faux) \\ b_i(1) = b_b(vrai) \lor b_i(1) = b_b(faux) \\ b_i(2) = b_b(vrai) \lor b_i(2) = b_b(faux)\end{cases} $
\\ \\
ce qui est \'equivalent \`a

$\begin{array}{lclclc}
& b_i(0) = b_i(1) & \lor & b_i(1) = b_i(2)&  \lor & b_i(0) = b_i(2) \\ \equiv &
 u_i(b_i(0)) = u_i(b_i(1))& \lor& u_i(b_i(1)) = u_i(b_i(2)) &\lor& u_i(b_i(0)) = u_i(b_i(2)) \\ \equiv &
 0=1 & \lor & 1=2 & \lor & 0=2 

\end{array}$

Il est donc possible avec cette propri\'et\'e de prouver le faux en partant du vrai. Donc elle rendrait \verifast{} incoh\'erent. 


			Le type tableau n'est pas pr\'esent dans la logique du premier ordre de \verifast. Cette logique permet \`a \verifast{} de communiquer avec les SMT-solvers. Apr\`es, avoir rajout\'e le type tableau \`a la logique de sp\'ecification, il fallait ajouter le type tableau \`a la logique du premier ordre. En effet, sans un type array, les fonctions de la th\'eorie des tableaux impl\'ement\'ees dans Z3 ne sont pas utilisables.
			
			Un type array a \'et\'e ajout\'e. Pour repr\'esenter un type dans une fonction g\'en\'erique, il lui faut des fonctions de boxing et d'unboxing. Ces fonctions ont donc \'et\'e impl\'ement\'ees.
			
			La premi\`ere id\'ee a \'et\'e d'impl\'ementer des fonctions de boxing et d'unboxing qui prennent en compte le type des indices et des \'el\'ements. Cette impl\'ementation \'etait incorrecte car \verifast{} d\'eclare ces fonctions de boxing et d'unboxing \`a Z3 d\`es le d\'ebut. Or, avant de lire le code, \verifast{} ne peut pas conna\^itre les types des tableaux qui vont appara\^itre dans la preuve.
			
			L'alternative \`a ce probl\`eme a \'et\'e de faire des fonctions de boxing et d'unboxing pour des tableaux de type \textit{inductive} pour le domaine et le co-domaine. Les tableaux utilisant d'autres types utiliseront les fonctions de boxing et d'unboxing des types de leurs domaine et co-domaine pour transformer leurs indices et \'el\'ements en type \textit{inductive}. Comme ces fonctions existent pour tous les types de Z3, cette alternative permet \`a \verifast{} de d\'eclarer, d\`es le d\'ebut, la fonction et son type sans perdre l'aspect g\'en\'erique.
			
			
		\subsubsection{Ajout des fonctions}
	Pour terminer l'impl\'ementation, il faut maintenant ajouter les fonctions select, store, constant\_array et array\_ext (extensionalit\'e). Il y a deux \'etapes : la premi\`ere est de choisir comment repr\'esenter  et r\'ecup\'erer ces fonctions dans le code de \verifast{}. La deuxi\`eme est de d\'efinir comment ces fonctions vont \^etre communiqu\'ees \`a Z3.
	
		\verifast{} interdit \`a deux fonctions ou pr\'edicats d'avoir un nom identique. Cette r\`egle est primordiale car elle permet \`a \verifast{} de d\'efinir toutes les primitives dans des biblioth\`eques annexes. Les fonctions de la th\'eorie des tableaux ont \'et\'e d\'efinies dans une nouvelle biblioth\`eque sous la forme de fonctions abstraites. Une fonction abstraite est une fonction qui n'a pas de corps. Ainsi, tous les programmes ant\'erieurs restent corrects et les noms restent disponibles si la biblioth\`eque n'est pas incluse.
		
		Les fonctions de la th\'eorie sont donc, dans un code annot\'e, des fonctions comme les autres. Il faut maintenant savoir comment les rep\'erer pour utiliser les fonctions primitives de Z3.
		
		Une possibilit\'e aurait \'et\'e de modifier le parseur et ainsi savoir directement quand est-ce qu'elles sont appel\'ees. Avec l'impl\'ementation actuelle, l'ajout des fonctions aurait n\'ecessit\'e un nombre injustifi\'e de modifications dans plusieurs fichiers. Par cons\'equent, une autre solution a \'et\'e choisie. 
		
		L'autre solution consiste \`a trouver un point pr\'ecis du code o\`u toutes les fonctions vont \^etre appel\'ees et o\`u un maximum de v\'erification aura d\'ej\`a \'et\'e faite. Ainsi, le nombre de v\'erifications \`a modifier sera minime et donc limitera la quantit\'e de modifications apport\'ees sans en changer la qualit\'e de ce qui a \'et\'e impl\'ement\'e.
		
		Lors de la derni\`ere v\'erification int\'eressante pour les fonctions abstraites, un filtrage sur le nom des fonctions permet aux primitives de la th\'eorie d'\^etre rep\'er\'ees et ainsi d'\^etre trait\'ees comme les fonctions de la th\'eorie des tableaux.
		
		Dans \verifast{}, les deux solveurs ont une API commune. Ainsi, si on veut ajouter de nouvelles fonctions pour communiquer avec Z3, on doit s'assurer que Redux saura quoi en faire.
		
			Redux ne conna\^it pas la th\'eorie des tableaux. Il faut donc que lorsqu'un utilisateur de \verifast{} utilise une fonction de la th\'eorie, Redux sache comment r\'eagir. La r\'eaction de Redux est de consid\'erer ces fonctions comme non-interpr\'et\'ees. L'utilisateur pourra prouver les m\^emes choses que s'il utilisait Z3 mais il devra faire les preuves alors qu'avec les Z3, les preuves dans le bon fragment seront automatis\'ees.
			
			Les fonctions sont des primitives dans Z3. L'impl\'ementation consiste donc \`a un appel de fonctions.
			
	
	\subsection{Biblioth\`eques}
		La biblioth\`eque de la th\'eorie des tableaux et, par extension, la biblioth\`eque des multi-ensembles ont \'et\'e ajout\'ees dans \verifast. Je ne vais pas vous pr\'esenter l'int\'egralit\'e des biblioth\'eques mais seulement les fixpoints et les lemmes importants.
		\subsubsection{Biblioth\`eques de la th\'eorie des tableaux}
			La biblioth\`eque de la th\'eorie des tableaux commencent par les fonctions de la th\'eorie et ces axiomes.
			\begin{lstlisting}
fixpoint u select<t,u> (array(t,u) arr, t x);
fixpoint array(t, u) store<t, u> (array(t, u) arr, t x, u y);
fixpoint array(t, u) constant_array<t,u> (u v);
fixpoint t array_ext<t, u> (array(t, u) a, array(t, u) b);
lemma void constant_select<t,u> (u v, t i)
  requires true;
  ensures select (constant_array<t,u>(v), i) == v;
{}
lemma void select_store<t,u> (array(t,u) arr, t x, u y, t z)
    requires true;
    ensures select (store(arr, x, y), z) 
    		== ((x == z) ? y : select (arr, z));
{}
lemma void array_extensionality<t, u>(array(t, u) a, array(t, u) b)
requires select(a, array_ext<t, u>(a, b)) 
		== select(b, array_ext<t, u>(a, b));
ensures a == b;
{}
			\end{lstlisting}
			$t$,$u$ sont les types g\'en\'eriques.
			
			Aujourd'hui, \verifast{} indique que les axiomes sont corrects alors que la preuve est vide, ce n'\'etait logiquement pas le cas avant l'automatisation de la th\'eorie.
			
			Les derniers pr\'edicats et lemmes majeurs de la biblioth\`eque sont le pr\'edicat $array\_model($int* a, int b, int e, array(int,int) arr$)$ repr\'esentant un tableau $a$ entre (a+b) et (a+e) par le tableau arr et le lemme $array\_model\_init(int*,int)$ transformant une liste d'entier en un tableau d'entier. Les pr\'edicats $integer(int*,int)$ et $ints(int*,int,list)$ utilis\'es ci-dessous repr\'esentent, respectivement, un pointeur d'entier et une liste d'entiers.
			\begin{lstlisting}
predicate array_model (int* a, int b, int e, array(int,int) arr) =
  (b >= e) ? true : (integer(a+b,?v) &*& select(arr, b) == v 
  			&*& array_model(a, b+1, e, arr));
  			
lemma void array_model_init(int* a, int length)
requires ints(a, length, _) &*& length >= 0;
ensures array_model(a, 0, length, _);
{...}

			\end{lstlisting}
			
			Par d\'efaut, le r\'esultat renvoy\'e malloc ou un tableau en C sont repr\'esent\'es comme une liste dans \verifast, d'o\`u l'importance du lemme $array\_model\_init$.
			\subsubsection{Biblioth\'eque des multi-ensembles}
			Les multi-ensembles sont repr\'esent\'es comme des tableaux avec des \'el\'ements de type $nat$.
			\begin{lstlisting}
  inductive multiset<t> = mk_multiset (array(t, nat));
			\end{lstlisting}
			Les fonctions principales sont $multiset\_select$ permettant de r\'ecup\'erer le nombre d'occurrences d'une valeur dans un multi-ensemble, $multiset\_empty$ permettant d'initialiser un multi-ensemble vide, $multiset\_add$ permettant d'ajouter un \'el\'ement \`a un multi-ensemble, $multi\_ext$ \'etant l'\'egalit\'e entre deux multi-ensembles et $array\_multiset$ permettant de r\'ecup\'erer le multi-ensemble des \'el\'ements d'un tableau.
			
			Le pr\'edicat le plus important de cette biblioth\`eque est $same\_multiset$(array(int,int) a1, array(int,int) a2, int b, int e$)$ indiquant que les tableaux $a1$ et $a2$ ont le m\^eme multi-ensemble d'\'el\'ements entre $b$ et $e$.
			
	\subsection{Quicksort}
		L'algorithme de tri Quicksort, d\'evelopp\'e par Hoare, (voir page 23/24) doit \^etre l'un des algorithmes le plus connu et le plus utilis\'e. M\^eme si sa correction a \'et\'e d\'emontr\'ee de nombreuses fois, certifier un programme \verifast{} revient \`a montrer que l'ensemble du code est correct avec \verifast. Il faut donc que les algorithmes les plus classiques soient de nouveau prouv\'es. L'algorithme du Quicksort n'\'etait pas prouv\'e en \verifast{} et \'etait un bon exemple pour illustrer l'int\'er\^et de la th\'eorie des tableaux. 
		
		J'ai d\'efini la sp\'ecification du Quicksort ainsi :\\
		\textbf{Pr\'econdition :} le tableau est bien d\'efini entre (a+lo) et (a+hi).\\
		\textbf{Postcondition :} le tableau est bien d\'efini entre (a+lo) et (a+hi), le multi-ensemble des \'el\'ements est inchang\'e et le tableau est tri\'e.
		
		L'algorithme du Quicksort utilise les fonctions $swap$ et $partition$.\\ La sp\'ecification de $swap$ a \'et\'e d\'efinie ainsi :\\
		\textbf{Pr\'econdition :} le tableau est bien d\'efini entre (a+lo) et (a+hi).\\
		\textbf{Postcondition :} le tableau est bien d\'efini entre (a+lo) et (a+hi) et les valeurs du tableau \`a la position i et j ont \'et\'e \'echang\'ees. \\
La sp\'ecification de $partition$ a \'et\'e d\'efinie ainsi :\\
		\textbf{Pr\'econdition :} le tableau est bien d\'efini entre (a+lo) et (a+hi).\\
		\textbf{Postcondition :} le tableau est bien d\'efini entre (a+lo) et (a+hi), le multi-ensemble des \'el\'ements du tableau est inchang\'e, le pivot est \`a la position que retourne la fonction, tous les \'el\'ements avant le pivot dans le tableau sont plus petits que le pivot et tous les \'el\'ements apr\`es le pivot dans le tableau sont plus grands que le pivot.
		
		La preuve de la fonction $partition$ se passe principalement dans la boucle. Les invariants de boucle importants sont que les \'elements entre $low$ et $i$ sont plus petits que le pivot, que les \'el\'ements entre $i+1$ et $j$ sont plus grands que le pivot et que le multi-ensemble reste le m\^eme.\\
		Ainsi, \`a la fin de la boucle, il ne reste plus qu'\`a incr\'ementer $i$ placer le pivot \`a la position $i$ et la postcondition est respect\'ee.
		
		La preuve de la fonction quicksort se repose sur deux cas, si le tableau est vide, c'est-\`a-dire, $lo > hi$, alors le tableau vide est d\'ej\`a tri\'e et le multi-ensemble des \'el\'ements reste vide. Si le tableau n'est pas vide, on appelle la fonction $partition$ puis on rappelle $quicksort$ r\'ecursivement sur les deux morceaux du tableau. Le morceau o\`u tous les \'el\'ements sont plus petits que $a[p]$ et le morceau o\`u les \'el\'ements sont plus grands que $a[p]$.
		
		Apr\`es l'appel \`a la fonction $partition$, les garanties de la postcondition de $partition$ sont que les \'el\'ements entre $lo$ et $p-1$ sont plus petits que $a[p]$, que les \'el\'ements entre $p+1$ et $hi$ sont plus grands que $a[p]$ et que le multi-ensemble des \'el\'ements n'a pas chang\'e. Il reste donc \`a rappeler l'algorithme du quicksort sur les deux parties du tableaux. Apr\`es les deux appels r\'ecursifs, les postconditions des deux appels \`a quicksort et \`a partition nous garantissent ceci :
		\begin{enumerate}
			\item Avant l'appel \`a quicksort, les \'el\'ements entre lo et p-1 sont plus petits que $a[p]$.
			\item Avant l'appel \`a quicksort, les \'el\'ements entre p+1 et hi sont plus grands que $a[p]$.
			\item Avant l'appel \`a quicksort, le multi-ensemble des \'el\'ements du tableau est le m\^eme qu'au d\'ebut.
			\item Apr\`es l'appel \`a quicksort, le multi-ensemble des \'el\'ements entre lo et p-1 est le m\^eme qu'avant l'appel \`a quicksort.
			\item Apr\`es l'appel \`a quicksort, le tableau est tri\'e entre lo et p-1.
			\item Apr\`es l'appel \`a quicksort, le multi-ensemble des \'el\'ements entre p+1 et hi est le m\^eme qu'avant l'appel \`a quicksort.
			\item Apr\`es l'appel \`a quicksort, le tableau est tri\'e entre p+1 et hi.\\ \\
			Il faut maintenant combiner les propri\'et\'es pour avoir les post-conditions voulues.
			\item En combinant (1) et (4), il est possible de montrer qu'apr\`es l'appel de quicksort, les \'el\'ements entre lo et p-1 sont plus petits que $a[p]$.
			\item En combinant (2) et (6), il est possible de montrer qu'apr\`es l'appel de quicksort, les \'el\'ements entre p+1 et hi sont plus grands que $a[p]$.
			\item En combinant (4) (6) et la valeur du pivot, il est possible de montrer que le multi-ensemble des \'el\'ements du tableau avant les appels \`a quicksort est le m\^eme qu'apr\`es.
			\item En appliquant la transitivit\'e de l'\'egalit\'e avec (3) et (10), il est possible de montrer que le multi-ensemble des \'el\'ements du tableau est le m\^eme au d\'ebut et apr\`es les appels r\'ecursifs.
			\item En combinant (5) (7) (8) et (9), il est possible de montrer qu'apr\`es les appels r\'ecursifs, le tableau est bien tri\'e.
		\end{enumerate}
		Pour autoriser les appels r\'ecursifs, un lemme est appel\'e . Ce lemme dit que si un tableau est bien d\'efini entre lo et hi et $lo <= p<=hi$, alors il existe un tableau bien d\'efini entre lo et p-1, un autre entre p+1 et hi et la case p est bien d\'efinie. Ce d\'ecoupage permet aux appels r\'ecursifs de respecter la pr\'econdition. Apr\`es les appels r\'ecursifs, un lemme inverse permet de reformer un tableau entre lo et hi. En consid\'erant les pr\'edicats (11) et (12), nous pouvons conclure que la postcondiction de l'algorithme du Quicksort est bien respect\'ee. \\
		
	55 lignes de code m'ont \'et\'e n\'ecesssaire pour ajouter le type tableau, ces restrictions et ces fonctions de boxing. L'ajout des fonctions de la th\'eorie des tableaux repr\'esente 140 lignes. Les biblioth\`eques font 858 lignes et la preuve du Quicksort fait 554 lignes. 
	
\section{Conclusion}
	
	L'automatisation de la th\'eorie des tableaux est aujourd'hui fonctionnelle dans \verifast. Les preuves dans le bon fragment de la th\'eorie des tableaux sont totalement automatis\'ees avec Z3. Les biblioth\`eques de la th\'eorie des tableaux et des multi-ensembles ont \'et\'e construites et l'algorithme du Quicksort a \'et\'e prouv\'e en \verifast{} \`a l'aide des biblioth\`eques et de l'automatisation. 
	
	Une suite possible \`a ce travail est d'automatiser de nouvelles th\'eories ou d'ajouter d'autres fonctions \`a la th\'eorie des tableaux.

\bibliographystyle{abbrv}
\bibliography{plan}


\appendix
\section*{Quicksort}
\begin{lstlisting}
void swap (int* a, int i, int j)
{
  int b = *(a+i);
  *(a+i) = *(a+j);
  *(a+j) = b;
}









int partition (int* arr, int lo, int hi)
{
  int pivot = a[hi];
  int i = lo - 1;
  int j;
  for (j = lo; j < hi; j++) {
    if (a[j] < pivot) {
      i++;
      if (i < j) swap(a, i, j);
    }
  }
  i++;
  if (i < hi) swap(a, i, hi);
  return i;
}

void quicksort (int* a, int lo, int hi)
{
  if (lo > hi) return;
  int p = partition(a, lo, hi);
  quicksort(a, lo, p-1);
  quicksort(a, p+1, hi);
}

		\end{lstlisting}
\end{document}
