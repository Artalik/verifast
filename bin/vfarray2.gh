#ifndef VFARRAY2_H
#define VFARRAY2_H

#include "intdiff.gh"

lemma void inj_S(nat a, nat b)
requires S(a) == S(b);
ensures a == b;
{}

fixpoint u select<t,u> (array(t,u) arr, t x);
fixpoint array(t, u) store<t, u> (array(t, u) arr, t x, u y);
fixpoint array(t, u) constant_array<t,u> (u v);
fixpoint t ext<t, u> (array(t, u) a, array(t, u) b);


// lemma_auto (get(constant_array<t,u>(v),i)) void constant_get<t,u> (u v, t i)
lemma void constant_select<t,u> (u v, t i);
  requires true;
  ensures select (constant_array<t,u>(v), i) == v;

lemma t array_ext<t,u>(array(t,u) A, array(t,u) B)
  requires A != B;
  ensures select(A, result) != select(B, result);
{
   assume (false);
   return ext(A, B);
}

// lemma_auto (get(set(arr, x, y), z)) void get_set<t,u> (array(t,u) arr, t x, u y, t z)
lemma void select_set<t,u> (array(t,u) arr, t x, u y, t z)
    requires true;
    ensures select (store(arr, x, y), z) == ((x == z) ? y : select (arr, z));
{ 
   assume (select (store(arr, x, y), z) == ((x == z) ? y : select (arr, z)));
}
/*
fixpoint int get<t,u> (array(int,int) arr, int x);
fixpoint array(t, u) set<t, u> (fixpoint(t, u) arr, t x, u y);
*/

// good 
inductive a<t> = a_intro (array(t, int));
inductive a' = a_intro' (array(a<int>, int));

//bad
//inductive a'' = a_intro'' (array(a'', int));


/*
fixpoint bool delta(a x) {
  switch(x) {
    case a_intro(f): return !(get<a,bool>(f, x));
    case dummy: return true;
  }
}
  
fixpoint a delta2() { return a_intro(delta); }

fixpoint bool omega () { return delta(delta2()); }

lemma void liar ()
  requires true;
  ensures omega == ! omega;
  { return; }

*/

lemma void array_model_out_of_range(int* a, int b, int e, array(int,int) arr, int i, int v)
  requires (i < b || i >= e) &*& array_model(a, b, e, arr);
  ensures array_model(a, b, e, store(arr, i, v));
{ assume(false); }

predicate array_model (int* a, int b, int e, array(int,int) arr) =
  (b >= e) ? true : (integer(a+b,?v) &*& select(arr, b) == v &*& array_model(a, b+1, e, arr));
  // (a[b] |-> ?v &*& select(arr, b) == v &*& array_model(a, b+1, e, arr));
  
lemma void empty_array(int* a, int i, array(int, int) arr)
requires true;
ensures array_model(a, i, i, arr);
{
  close array_model(a, i, i, arr);
}
lemma void array_model_init(int* a, int length)
  requires ints((void*)a, length, _) &*& length >= 0;
  ensures array_model(a, 0, length, _);
  { assume (false);}

lemma void close_array_model_right(nat n)
requires array_model(?a, ?b, ?e, ?arr) &*& b <= e &*& int_diff(b, e, n) == true &*& a[e] |-> select(arr, e);
ensures array_model(a, b, e+1, arr);
{
  switch(n) {
    case O: {
      open array_model(a, b, e, arr);
      assert (b == e);
      close array_model(a, e+1, e+1, arr);
      close array_model(a, b, e+1, arr);
    }
    case S(p): {
      open array_model(a, b, e, arr);
      close_array_model_right(p);
      close array_model(a, b, e+1, arr);
    }
  }
}

lemma void array_model_init_diff(int* a, int length, nat n)
  requires ints((void*)a, length, _) &*& length >= 0 &*& int_diff(0, length, n) == true;
  ensures array_model(a, 0, length, _);
{ 
   switch (n) {
     case (O) : {
     	empty_array(a,0,constant_array<int,int>(0));
     }
     case (S (p)) : 
     {
     	open_ints_right (p);
     	int_diff_translate(1,length,-1,p);
     	array_model_init_diff(a,length-1,p);
     	assert a[length-1] |-> ?v;
     	assert array_model(a, 0, length-1, ?arr);
        array_model_out_of_range(a, 0, length-1, arr, length-1, v);
     	close_array_model_right(p);
     	int_diff_translate(0,length-1,1,p);
//     	close array_model(a, 0, length, constant_array<int,int>(0));
     }
     }
}

lemma void array_model_delete(int* a, int length)
  requires array_model(a, 0, length, _) &*& length > 0;
  ensures chars((void*)a, length*sizeof(int), _);
{ assume(false); }

lemma void array_model_select_unfold(int* a, int b, int e, array(int,int) arr, int i)
  requires array_model(a, b, e, arr) &*& b <= i &*& i < e;
  ensures array_model(a, b, i, arr) &*& a[i] |-> select(arr, i) &*& array_model(a, i+1, e, arr);
{ assume(false); }

lemma void array_model_set_fold(int* a, int b, int e, array(int,int) arr, int i)
  requires array_model(a, b, i, arr) &*& a[i] |-> ?v &*& array_model(a, i+1, e, arr) &*& b <= i &*& i < e;
  ensures array_model(a, b, e, store(arr, i, v));
{ assume(false); }


// This is a consequence of array_model_set_fold if we have extensionality
lemma void array_model_select_fold(int* a, int b, int e, array(int,int) arr, int i)
  requires array_model(a, b, i, arr) &*& a[i] |-> select(arr, i) &*& array_model(a, i+1, e, arr) &*& b <= i &*& i < e;
  ensures array_model(a, b, e, arr);
{  if (arr != store(arr, i, select(arr, i))) {
    	int j = array_ext(arr, store(arr, i, select(arr, i)));
    	assert select(arr, j) != select(store(arr, i, select(arr, i)), j);
    	select_set(arr, i, select(arr, i), j);
    	assert false;
    } else {
    	array_model_set_fold(a, b, e, arr, i);
    }
}




     

/*inductive ensemble = set_intro (fixpoint(ensemble,int));
inductive ensemble'''<t> = set_intro''' (fixpoint(t,int));
inductive ensemble'<t> = set_intro' (array(int,t));
inductive ensemble''<t> = set_intro'' (array(t,t));
*/



#endif
