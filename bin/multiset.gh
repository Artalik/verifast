#ifndef MULTISET_H
#define MULTISET_H

/*

Multiset encoded as mappings ranging in nat.

The primitives are:
- the empty multiset: empty_multiset()
- multiset membership (returning a nat): mutliset_select(m, x)
- insertion of an element: multiset_add(m, x)
- extensionality: multiset_ext(m1, m2) is an x such that multiset_select(m1, x) != multiset_select(m2, x) if m1 != m2

*/

#include "mapping.gh"

lemma void note(bool b)
requires b == true;
ensures b == true;
{}

fixpoint nat multiset_select<t>(mapping(t, nat) m, t i) {
  return select(m, i);
}

fixpoint mapping(t, nat) empty_multiset<t>() {
  return (constant_mapping<t,nat>(zero));
}

fixpoint mapping(t, nat) multiset_add<t>(mapping(t, nat) m, t i) {
  return store(m, i, succ(select(m, i)));
}

lemma t multiset_ext<t>(mapping(t, nat) m1, mapping(t, nat) m2)
  requires m1 != m2;
  ensures multiset_select(m1, result) != multiset_select(m2, result);
{
  return mapping_ext(m1, m2);
}

// Properties of multiset_add

lemma_auto (multiset_select(multiset_add(m, i), j)) void select_add<t>(mapping(t, nat) m, t i, t j)
  requires true;
  ensures multiset_select(multiset_add(m, i), j) == ((i == j) ? succ(multiset_select(m, i)) : multiset_select(m ,j));
{}

lemma void multiset_add_commutes<a>(mapping(a, nat) M, a x, a y)
requires true;
ensures multiset_add(multiset_add(M, y), x) == multiset_add(multiset_add(M, x), y);
{}

lemma void regular_multiset_add<a>(mapping(a, nat) MA, mapping(a, nat) MB, a x)
requires multiset_add(MA,x) == multiset_add(MB,x);
ensures MA == MB;
{}

lemma mapping(a, nat) multiset_add_join<a>(mapping(a, nat) m1, mapping(a, nat) m2, a x, a y)
requires multiset_add(m1, x) == multiset_add(m2, y) &*& x != y;
ensures m1 == multiset_add(result, y) &*& m2 == multiset_add(result, x);
{
  switch(multiset_select(m1, y)) {
    case zero: assert false;
    case succ(p): return store(m1, y, p);
  }
}

// Finiteness of a multiset

// l is the list [x1; ...; xn], m is the finite multiset {x1; ...; xn} and all xi satisfy p
predicate finite_multiset_list<t>(list<t> l, fixpoint(t, bool) p; mapping(t, nat) m, nat n) =
  l == nil ?
    (m == empty_multiset() &*& n == zero)
  : (l == cons(?x, ?tl) &*& finite_multiset_list(tl, p, ?mm, ?pred) &*& p(x) == true &*& m == multiset_add(mm, x) &*& n == succ(pred));

// m is a finite multiset of n elements that all satisfy p
predicate finite_multiset<t>(fixpoint(t, bool) p, mapping(t, nat) m, nat card) = finite_multiset_list(_, p, m, card);

lemma void finite_empty_multiset<t>(fixpoint(t, bool) p)
requires true;
ensures finite_multiset(p, empty_multiset<t>(), zero);
{
  close finite_multiset_list(nil, p, empty_multiset(), zero);
  close finite_multiset(p, empty_multiset(), zero);
}

lemma void finite_multiset_is_empty<t>(fixpoint(t, bool) p, mapping(t, nat) m)
requires finite_multiset(p, m, zero);
ensures m == empty_multiset();
{
  open finite_multiset(p, m, zero);
  assert finite_multiset_list(?l, p, m, zero);
  switch(l) {
    case nil: open finite_multiset_list(nil, p, m, zero);
    case cons(hd, tl): {
      open finite_multiset_list(cons(hd, tl), p, m, zero);
      assert false;
    }
  }
}

lemma void finite_multiset_add<t>(fixpoint(t, bool) p, mapping(t, nat) m, t x)
requires finite_multiset(p, m, ?n) &*& p(x) == true;
ensures finite_multiset(p, multiset_add(m, x), succ(n));
{
  open finite_multiset(p, m, n);
  assert finite_multiset_list(?l, p, m, n);
  close finite_multiset_list(cons(x, l), p, multiset_add(m, x), succ(n));
  close finite_multiset(p, multiset_add(m, x), succ(n));
}

lemma pair<t, mapping(t, nat) > finite_multiset_destruct<t>(fixpoint(t, bool) p, mapping(t, nat) m, nat n)
requires finite_multiset(p, m, succ(n));
ensures m == multiset_add(snd(result), fst(result)) &*& finite_multiset(p, snd(result), n) &*& p(fst(result)) == true;
{
  open finite_multiset(p, m, succ(n));
  open finite_multiset_list(?l, p, m, succ(n));
  switch(l) {
    case nil: assert false;
    case cons(x, l2): {
      assert finite_multiset_list(l2, p, ?m2, n) &*& m == multiset_add(m2, x);
      close finite_multiset(p, m2, n);
      return pair(x, m2);
    }
  }
}

lemma void finite_multiset_remove<t>(fixpoint(t, bool) p, mapping(t, nat) m, t x, nat n)
requires finite_multiset(p, multiset_add(m, x), succ(n));
ensures finite_multiset(p, m, n) &*& p(x) == true;
{
  switch(n) {
    case zero: {
      pair <t, mapping(t, nat) > ym2 = finite_multiset_destruct(p, multiset_add(m, x), n);
      t y = fst(ym2);
      mapping(t, nat) m2 = snd(ym2);
      finite_multiset_is_empty(p, m2);
      if (x != y) { switch(multiset_select(multiset_add(m2, y), x)) {case zero: case succ(pred):} assert false; }
      regular_multiset_add(m, m2, x);
      finite_empty_multiset(p);
    }
    case succ(pred): {
      pair <t, mapping(t, nat) > ym2 = finite_multiset_destruct(p, multiset_add(m, x), n);
      t y = fst(ym2);
      mapping(t, nat) m2 = snd(ym2);
      if (x == y) {
        regular_multiset_add(m, m2, x);
      } else {
        mapping(t, nat) m3 = multiset_add_join(m, m2, x, y);
        finite_multiset_remove(p, m3, x, pred);
        finite_multiset_add(p, m3, y);
        multiset_add_commutes(m3, y, x);
      }
    }
  }
}

lemma void finite_multiset_clear<t>(fixpoint(t, bool) p, mapping(t, nat) m, nat n)
requires finite_multiset(p, m, n);
ensures true;
{
  switch(n) {
    case zero: {
      finite_multiset_is_empty(p, m);
    }
    case succ(pred): {
      pair <t, mapping(t, nat) > xm2 = finite_multiset_destruct(p, m, pred);
      t x = fst(xm2);
      mapping(t, nat) m2 = snd(xm2);
      finite_multiset_clear(p, m2, pred);
    }
  }
}

lemma void finite_multiset_dup<t>(fixpoint(t, bool) p, mapping(t, nat) m, nat n)
requires finite_multiset(p, m, n);
ensures finite_multiset(p, m, n) &*& finite_multiset(p, m, n);
{
  switch(n) {
    case zero: {
      finite_multiset_is_empty(p, m);
      finite_empty_multiset(p);
      finite_empty_multiset(p);
    }
    case succ(pred): {
      pair <t, mapping(t, nat) > xm2 = finite_multiset_destruct(p, m, pred);
      t x = fst(xm2);
      mapping(t, nat) m2 = snd(xm2);
      finite_multiset_dup(p, m2, pred);
      finite_multiset_add(p, m2, x);
      finite_multiset_add(p, m2, x);
    }
  }
}

lemma mapping(t, nat) finite_multiset_select<t>(fixpoint (t, bool) p, mapping(t, nat) m, nat n, t x)
requires finite_multiset(p, m, n) &*& multiset_select(m, x) != zero;
ensures finite_multiset(p, m, n) &*& p(x) == true &*& m == multiset_add(result, x);
{
  switch(n) {
    case zero: {
      finite_multiset_is_empty(p, m);
      assert false;
    }
    case succ(pred): {
      pair <t, mapping(t, nat) > ym2 = finite_multiset_destruct(p, m, pred);
      t y = fst(ym2);
      mapping(t, nat) m2 = snd(ym2);
      if (x != y) {
        mapping(t, nat) m3 = finite_multiset_select(p, m2, pred, x);
        finite_multiset_add(p, m2, y);
        assert m == multiset_add(m2, y);
        assert m2 == multiset_add(m3, x);
        multiset_add_commutes(m3, x, y);
        return multiset_add(m3, y);
      } else {
        finite_multiset_add(p, m2, y);
        return m2;
      }
    }
  }
}

// The (finite) multiset of values stored in a mapping between indexes b (included) and b+n (excluded)
fixpoint mapping(int, nat) mapping_multiset(int b, nat n, mapping(int,int) mp) {
  switch(n) {
    case zero: return empty_multiset();
    case succ(p): return multiset_add(mapping_multiset(b+1, p, mp), select(mp, b));
  }
}

// The trivial predicate
fixpoint bool truep<t>(t x) { return true; }

lemma void mapping_multiset_finite(int b, nat n, mapping(int, int) mp)
requires true;
ensures finite_multiset(truep, mapping_multiset(b, n, mp), n);
{
  switch(n) {
    case zero: {
      finite_empty_multiset<int>(truep);
    }
    case succ(p): {
      mapping_multiset_finite(b+1, p, mp);
      finite_multiset_add(truep, mapping_multiset(b+1, p, mp), select(mp, b));
    }
  }
}

lemma void mapping_multiset_right(mapping(int, int) A, int b, int e, nat n)
requires int_diff(b, e, n) == true &*& b <= e;
ensures mapping_multiset(b, succ(n), A) == multiset_add(mapping_multiset(b, n, A), select(A, e));
{
  switch(n) {
    case zero:
    case succ(p): {
      mapping_multiset_right(A, b+1, e, p);
      multiset_add_commutes(mapping_multiset(b+1, p, A), select(A, e), select(A, b));
    }
  }
}

lemma int mapping_multiset_assoc(mapping(int, int) a, int b, int e, int v, nat l)
requires multiset_select(mapping_multiset(b, l, a), v) != zero &*& int_diff(b, e, l) == true;
ensures select(a, result) == v &*& b <= result &*& result < e;
{
  switch(l) {
    case zero: {
      open mapping_multiset(b, e, a, m);
      assert false;
    }
    case succ(p): {
      if (select(a, b) == v) {
        return b;
      } else {
        return mapping_multiset_assoc(a, b+1, e, v, p);
      }
    }
  }
}

lemma void mapping_multiset_select(mapping(int, int) a, int b, int e, int i, nat l)
requires b <= i &*& i < e &*& int_diff(b, e, l) == true;
ensures multiset_select(mapping_multiset(b, l, a), select(a, i)) != zero;
{
  switch(l) {
    case zero: assert false;
    case succ(p): {
      if (b != i) {
        mapping_multiset_select(a, b+1, e, i, p);
      }
    }
  }
}

lemma mapping(int, nat) multiset_select_in(int b, int e, nat n, mapping(int, int) start, int k)
requires int_diff(b, e, n) == true &*& b <= k &*& k < e;
ensures mapping_multiset(b, n, start) == multiset_add(result, select(start, k));
{
  mapping_multiset_finite(b, n, start);
  mapping_multiset_select(start, b, e, k, n);
  mapping(int, nat) m = finite_multiset_select(truep, mapping_multiset(b, n, start), n, select(start, k));
  finite_multiset_clear(truep, mapping_multiset(b, n, start), n);
  return m;
}

// Having the same multiset of elements, this is a way to express that a2 is a permutation of a1
predicate same_multiset(mapping(int,int) a1, mapping(int,int) a2, int b, int e) =
  mapping_multiset(b, nat_of_int(e-b), a1) == mapping_multiset(b, nat_of_int(e-b), a2);

lemma void close_same_multiset(mapping(int, int) a1, mapping(int, int) a2, int b, int e)
requires same_multiset(a1, a2, b, e) &*& select(a1, b-1) == select(a2, b-1) &*& b <= e;
ensures same_multiset(a1, a2, b-1, e);
{
  open same_multiset(a1, a2, b, e);
  nat n = nat_of_int(e-b);
  note(mapping_multiset(b-1, nat_of_int(e-(b-1)), a1) == mapping_multiset(b-1, succ(n), a1));
  note(mapping_multiset(b-1, nat_of_int(e-(b-1)), a2) == mapping_multiset(b-1, succ(n), a2));
  close same_multiset(a1, a2, b-1, e);
}

lemma void same_multiset_refl (mapping(int,int) start, int b, int e)
  requires true;
  ensures same_multiset(start, start, b, e);
{
  close same_multiset(start, start, b, e);
}

lemma void same_multiset_sym(mapping(int, int) start, mapping(int, int) end, int b, int e)
requires same_multiset(start, end, b, e);
ensures same_multiset(end, start, b, e);
{
  open same_multiset(start, end, b, e);
  close same_multiset(end, start, b, e);
}

lemma void same_multiset_trans(mapping(int, int) start, mapping(int, int) middle, mapping(int, int) end, int b, int e)
  requires same_multiset(start, middle, b, e) &*& same_multiset(middle, end, b, e);
  ensures same_multiset(start, end, b, e);
{
  open same_multiset(middle, end, b, e);
  open same_multiset(start, middle, b, e);
  close same_multiset(start, end, b, e);
}

lemma void same_multiset_add_at_end(mapping(int, int) start, mapping(int, int) end, int b, int e)
  requires same_multiset(start, end, b, e) &*& select(start, e) == select(end, e) &*& b <= e;
  ensures same_multiset(start, end, b, e+1);
{
  open same_multiset(start,end,b,e);
  int_diff_nat_of_int(b, e);
  mapping_multiset_right(start, b, e, nat_of_int(e-b));
  mapping_multiset_right(end, b, e, nat_of_int(e-b));
  close same_multiset(start, end, b, e+1);
}

lemma int same_multiset_assoc(mapping(int, int) start, mapping(int, int) end, int b, int e, int i)
  requires same_multiset(start, end, b, e) &*& b <= i &*& i < e;
  ensures same_multiset(start, end, b, e) &*& select(start, i) == select(end, result) &*& b <= result &*& result < e;
{
   open same_multiset(start, end, b, e);
   int_diff_nat_of_int(b, e);
   mapping_multiset_select(start, b, e, i, nat_of_int(e-b));
   int j = mapping_multiset_assoc(end, b, e, select(start, i), nat_of_int(e-b));
   close same_multiset(start, end, b, e);
   return j;
}

lemma void same_multiset_store_out_left(int b, int e, nat n, mapping(int, int) start, int k, int v)
  requires k < b &*& int_diff(b, e, n) == true &*& b <= e;
  ensures same_multiset(start, store(start, k, v), b, e);
{
  switch(n) {
    case zero: close same_multiset(start, store(start, k, v), b, e);
    case succ(p): {
      same_multiset_store_out_left(b+1, e, p, start, k, v);
      close_same_multiset(start, store(start, k, v), b+1, e);
    }
  }
}

lemma void same_multiset_store_out_right(int b, int e, nat n, mapping(int, int) start, int k, int v)
  requires e <= k &*& int_diff(b, e, n) == true &*& b <= e;
  ensures same_multiset(start, store(start, k, v), b, e);
{
  switch(n) {
    case zero: close same_multiset(start, store(start, k, v), b, e);
    case succ(p): {
      same_multiset_store_out_right(b+1, e, p, start, k, v);
      close_same_multiset(start, store(start, k, v), b+1, e);
    }
  }
}

lemma void same_multiset_store_in(int b, int e, nat n, mapping(int, int) start, mapping(int, nat) m, int k, int v)
  requires mapping_multiset(b, n, start) == multiset_add(m, select(start, k)) &*& int_diff(b, e, n) == true &*& b <= k &*& k < e;
  ensures mapping_multiset(b, n, store(start, k, v)) == multiset_add(m, v);
{
  switch(n) {
    case zero: assert false;
    case succ(p): {
      if (b == k) {
        same_multiset_store_out_left(b+1, e, p, start, k, v);
        int_diff_le(b+1, e, p);
        open same_multiset(start, store(start, k, v), b+1, e);
        regular_multiset_add(m, mapping_multiset(b+1, p, store(start, k, v)), select(start, k));
      } else {
        if(select(start, b) == select(start, k)) {
          mapping(int, nat) m2 = multiset_select_in(b+1, e, p, start, k); // AM(b+1, p, start) == m2 + {start[k]}
          regular_multiset_add(mapping_multiset(b+1, p, start), m, select(start, b)); // AM(b+1, p, start) == m
          same_multiset_store_in(b+1, e, p, start, m2, k, v); // AM(b+1, p, end) == m2 + {v}
          multiset_add_commutes(m2, select(start, k), v);
        } else {
          mapping(int, nat) m2 = multiset_add_join(mapping_multiset(b+1, p, start), m, select(start, b), select(start, k)); // AM(b+1, p, start) == m2 + {start[k]}, m == m2 + {start[b]}
          same_multiset_store_in(b+1, e, p, start, m2, k, v); // AM(b+1, p, end) == m2 + {v}
          multiset_add_commutes(m2, select(start, b), v);
        }
      }
    }
  }
}

// To prove the same_multiset_concat lemma below, we need to generalize mapping_multiset to a "linear" version
// plugging an arbitrary multiset m in the base case.
fixpoint mapping(int, nat) mapping_multiset_linear(int b, nat n, mapping(int, int) mp, mapping(int, nat) m) {
  switch(n) {
    case zero: return m;
    case succ(p): return multiset_add(mapping_multiset_linear(b+1, p, mp, m), select(mp, b));
  }
}

lemma void mapping_multiset_linear_empty(int b, nat n, mapping(int, int) mp)
requires true;
ensures mapping_multiset_linear(b, n, mp, empty_multiset()) == mapping_multiset(b, n, mp);
{
  switch(n) {
    case zero:
    case succ(p): {
      mapping_multiset_linear_empty(b+1, p, mp);
    }
  }
}

lemma void mapping_multiset_linear_add(int b, nat n, mapping(int, int) mp, mapping(int, nat) m, int x)
requires true;
ensures mapping_multiset_linear(b, n, mp, multiset_add(m, x)) == multiset_add(mapping_multiset_linear(b, n, mp, m), x);
{
  switch(n) {
    case zero:
    case succ(p): {
      mapping_multiset_linear_add(b+1, p, mp, m, x);
      multiset_add_commutes(mapping_multiset_linear(b+1, p, mp, m), x, select(mp, b));
    }
  }
}

lemma void same_mapping_multiset_linear(int b, int e, nat n, mapping(int, int) mp1, mapping(int, int) mp2, mapping(int, nat) m, nat c)
requires same_multiset(mp1, mp2, b, e) &*& b <= e &*& int_diff(b, e, n) == true &*& finite_multiset(truep, m, c);
ensures mapping_multiset_linear(b, n, mp1, m) == mapping_multiset_linear(b, n, mp2, m);
{
  switch(c) {
    case zero: {
      finite_multiset_is_empty(truep, m);
      mapping_multiset_linear_empty(b, n, mp1);
      mapping_multiset_linear_empty(b, n, mp2);
      open same_multiset(mp1, mp2, b, e);
      int_diff_le(b, e, n);
    }
    case succ(p): {
      pair <int, mapping(int, nat) > xm2 = finite_multiset_destruct(truep, m, p);
      int x = fst(xm2);
      mapping(int, nat) m2 = snd(xm2);
      same_mapping_multiset_linear(b, e, n, mp1, mp2, m2, p);
      mapping_multiset_linear_add(b, n, mp1, m2, x);
      mapping_multiset_linear_add(b, n, mp2, m2, x);
    }
  }
}

lemma void mapping_multiset_linear_concat(mapping(int, int) mp, int b, int e0, int e1, nat left)
requires b <= e0 &*& e0 <= e1 &*& int_diff(b, e0, left) == true;
ensures mapping_multiset(b, nat_of_int(e1-b), mp) == mapping_multiset_linear(b, left, mp, mapping_multiset(e0, nat_of_int(e1-e0), mp));
{
  switch(left) {
    case zero:
    case succ(p): {
      mapping_multiset_linear_concat(mp, b+1, e0, e1, p);
      mapping(int, nat) m = mapping_multiset(e0, nat_of_int(e1-e0), mp);
      note (nat_of_int(e1-b) == succ(nat_of_int(e1-b-1)));
    }
  }
}

lemma void same_mapping_same_multiset(mapping(int, int) mp1, mapping(int, int) mp2, int b, nat n)
requires same_mapping(mp1, mp2, b, n) == true;
ensures mapping_multiset(b, n, mp1) == mapping_multiset(b, n, mp2);
{
  switch(n) {
    case zero:
    case succ(pred): same_mapping_same_multiset(mp1, mp2, b+1, pred);
  }
}

lemma void same_multiset_concat(mapping(int, int) mp1, mapping(int, int) mp2, int b, int e0, int e1)
requires same_multiset(mp1, mp2, b, e0) &*& same_multiset(mp1, mp2, e0, e1) &*& b <= e0 &*& e0 <= e1;
ensures same_multiset(mp1, mp2, b, e1);
{
  int_diff_nat_of_int(b, e0);
  mapping_multiset_linear_concat(mp1, b, e0, e1, nat_of_int(e0-b));
  mapping_multiset_linear_concat(mp2, b, e0, e1, nat_of_int(e0-b));
  open same_multiset(mp1, mp2, e0, e1);
  mapping(int, nat) m = mapping_multiset(e0, nat_of_int(e1-e0), mp1);
  mapping_multiset_finite(e0, nat_of_int(e1-e0), mp1);
  same_mapping_multiset_linear(b, e0, nat_of_int(e0-b), mp1, mp2, m, nat_of_int(e1-e0));
  close same_multiset(mp1, mp2, b, e1);
}
#endif
