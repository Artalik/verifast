#include "vfarray2.gh"

inductive multiset<t> = mk_multiset (array(t, nat));

fixpoint nat multiset_select<t>(multiset<t> m, t i) {
  switch(m) {
    case mk_multiset(a): return select(a, i);
  }
}

fixpoint multiset<t> empty_multiset<t>() {
  return (mk_multiset(constant_array<t,nat>(O)));
}

fixpoint multiset<t> multiset_add<t>(multiset<t> m, t i) {
  switch(m) {
    case mk_multiset(a):
      return mk_multiset(store(a, i, S(select(a, i))));
  }
}

lemma t multiset_ext<t>(multiset<t> m1, multiset<t> m2)
  requires m1 != m2;
  ensures multiset_select(m1, result) != multiset_select(m2, result);
{ 
   switch (m1) {
     case mk_multiset(a1): {
       switch (m2) {
         case mk_multiset(a2): {
           return array_ext(a1, a2);
         }       
       }     
     }
   }
}

/*
lemma_auto (multiset_get(empty_multiset(), i)) void get_empty(int i)
  requires true;
  ensures multiset_get(empty_multiset(), i) == O;
{ }
*/

lemma_auto (multiset_select(multiset_add(m, i), j)) void select_add<t>(multiset<t> m, t i, t j)
  requires true;
  ensures multiset_select(multiset_add(m, i), j) == ((i == j) ? S(multiset_select(m, i)) : multiset_select(m ,j));
{ 
   switch (m) {
     case mk_multiset(a): {}}
}

predicate array_multiset_bis(int b, int e, array(int,int) arr; multiset<int> m, nat length) =
  (b >= e) ? (m == empty_multiset() &*& length == O) :
     (array_multiset_bis(b+1, e, arr, ?tl, ?pred) &*&
      m == multiset_add(tl, select(arr, b)) &*&
      length == S(pred));

predicate array_multiset(int b, int e, array(int,int) arr; multiset<int> m) =
  (b >= e) ? (m == empty_multiset()) :
     (array_multiset(b+1, e, arr, ?tl) &*&
      m == multiset_add(tl, select(arr, b)));

predicate same_multiset(array(int,int) a1, array(int,int) a2, int b, int e) =
  array_multiset(b, e, a1, ?m) &*& array_multiset(b, e, a2, m);




lemma void array_multiset_is_notbis(int b, int e, array(int,int) a, nat l)
requires array_multiset_bis(b, e, a, ?m, l) &*& int_diff(b, e, l) == true;
ensures array_multiset(b, e, a, m);
{
  switch(l) {
    case O: {
      open array_multiset_bis(b, e, a, m, l);
      close array_multiset(b, e, a, m);
    }
    case S(p): {
      open array_multiset_bis(b, e, a, m, l);
      array_multiset_is_notbis(b+1, e, a, p);
      close array_multiset(b, e, a, m);
    }
  }
}

lemma void array_multiset_is_bis(int b, int e, array(int,int) a, nat l)
requires array_multiset(b, e, a, ?m) &*& int_diff(b, e, l) == true;
ensures array_multiset_bis(b, e, a, m, l);
{
  switch(l) {
    case O: {
      open array_multiset(b, e, a, m);
      close array_multiset_bis(b, e, a, m, _);
    }
    case S(p): {
      open array_multiset(b, e, a, m);
      array_multiset_is_bis(b+1, e, a, p);
      close array_multiset_bis(b, e, a, m, _);
    }
  }
}

lemma void same_multiset_address(array(int,int) m, int b, int e)
  requires array_multiset(b, e, m, ?MA) &*& array_multiset(b, e, m, ?MB);
  ensures MA == MB;
  {
       open array_multiset(b, e, _, _);
       open array_multiset(b, e, _, _);
       if (b < e) same_multiset_address(m, b+1, e);
  }


lemma void close_same_multiset(array(int, int) a1, array(int, int) a2, int b, int e)
requires same_multiset(a1, a2, b, e) &*& select(a1, b-1) == select(a2, b-1);
ensures same_multiset(a1, a2, b-1, e);
{
  open same_multiset(a1, a2, b, e);
  assert array_multiset(b, e, a1, ?m) &*& array_multiset(b, e, a2, m);
  close array_multiset(b-1, e, a1, _);
  close array_multiset(b-1, e, a2, _);
  close same_multiset(a1, a2, b-1, e);
}

  
lemma void multiset_add_commutes<a>(multiset<a> M, a x, a y)
requires true;
ensures multiset_add(multiset_add(M, y), x) == multiset_add(multiset_add(M, x), y);
{
  multiset<a> My = multiset_add(M, y);
  multiset<a> Mx = multiset_add(M, x);
  multiset<a> Myx = multiset_add(My, x);
  multiset<a> Mxy = multiset_add(Mx, y);
  if (Myx != Mxy) {
    a z = multiset_ext(Myx, Mxy);
  }
}

lemma void regular_multiset_add<a>(multiset<a> MA, multiset<a> MB, a x)
   requires multiset_add(MA,x) == multiset_add(MB,x);
   ensures MA == MB;
   {
     if( MA != MB){
       a t = multiset_ext(MA,MB);
       
       	 select_add(MA, x, t);
       	 select_add(MB, x, t);
       if (x == t){
         inj_S(multiset_select(MA,x),multiset_select(MB,x));
       }
         
     }
   }

// Not yet used
lemma void clear_array_multiset(int b, int e, array(int, int) A)
requires array_multiset(b, e, A, ?m);
ensures true;
{
  if (b >= e) {
    open array_multiset(b, e, A, _);
  } else {
  int i = b;
  for(; i < e; i++)
    invariant b <= i &*& i <= e &*& array_multiset(i, e, A, _);
    decreases e - i;
    {
      open array_multiset(i, e, A, _);
    }
    open array_multiset(e, e, A, _);
}
}
   
lemma void array_multiset_right(array(int, int) A, int b, int e)
requires b <= e &*& array_multiset(b, e, A, ?m);
ensures array_multiset(b, e+1, A, multiset_add(m, select(A, e)));
{
  int i = e;
  for (; i > b; i--)
    invariant b <= i &*& i <= e &*& array_multiset(i, e, A, ?mi) &*& array_multiset(i, e+1, A, ?mi2) &*& mi2 == multiset_add(mi, select(A, e));
    decreases i - b;
  {
     close array_multiset(i-1, e, A, multiset_add(mi, select(A, i-1)));
     close array_multiset(i-1, e+1, A, multiset_add(mi2, select(A, i-1)));
     multiset_add_commutes(mi, select(A, i-1), select(A, e));
  }
  same_multiset_address(A, b, e);
}


lemma void same_multiset_refl (array(int,int) start, int b, int e)
  requires true;
  ensures same_multiset(start, start, b, e);
{
   if (b >= e) {
     close array_multiset(b, e, start, empty_multiset());
     close array_multiset(b, e, start, empty_multiset());
     close same_multiset(start, start, b, e);
   } else {
     int i = e;
     close array_multiset(i, e, start, empty_multiset());
     close array_multiset(i, e, start, empty_multiset());
     close same_multiset(start, start, i, e);
     for (; i > b; i--)
       invariant b <= i &*& i <= e &*& same_multiset(start, start, i, e);
       decreases (i-b);
       {
          open same_multiset(start, start, i, e);
          assert array_multiset(i, e, start, ?tl);
          close array_multiset(i-1, e, start, multiset_add(tl, select(start, i-1)));
          close array_multiset(i-1, e, start, multiset_add(tl, select(start, i-1)));
          close same_multiset(start, start, i-1, e);
       }
   }
}

lemma void same_multiset_sym(array(int, int) start, array(int, int) end, int b, int e)
requires same_multiset(start, end, b, e);
ensures same_multiset(end, start, b, e);
{
  open same_multiset(start, end, b, e);
  close same_multiset(end, start, b, e);
}

lemma void same_multiset_trans(array(int, int) start, array(int, int) middle, array(int, int) end, int b, int e)
  requires same_multiset(start, middle, b, e) &*& same_multiset(middle, end, b, e);
  ensures same_multiset(start, end, b, e);
{ 
  if (b >= e) {
    close same_multiset(start, end, b, e);
    open same_multiset(middle, end, b, e);
    open same_multiset(start, middle, b, e);
  }else{
    open same_multiset(middle, end, b, e);
    assert array_multiset(b, e, middle, ?m);
    open same_multiset(start, middle, b, e);
    assert array_multiset(b, e, middle, ?m0);
    same_multiset_address(middle, b, e);
    close same_multiset(start, end, b, e);
  }
}


lemma void same_multiset_add_at_end(array(int, int) start, array(int, int) end, int b, int e)
  requires same_multiset(start, end, b, e) &*& select(start, e) == select(end, e);
  ensures same_multiset(start, end, b, e+1);
{
  if (b > e) {
  	close array_multiset(b, e+1, start, empty_multiset());
  	close array_multiset(b, e+1, end, empty_multiset());
  	close same_multiset(start, end, b, e+1);
  	open same_multiset(start,end,b,e);
  }else{
        open same_multiset(start,end,b,e);
        array_multiset_right(start, b, e);
        array_multiset_right(end, b, e);
        close same_multiset(start, end, b, e+1);
  }
}

lemma int array_multiset_assoc(array(int, int) a, int b, int e, int v, nat l)
requires array_multiset(b, e, a, ?m) &*& multiset_select(m, v) != O &*& int_diff(b, e, l) == true;
ensures array_multiset(b, e, a, m) &*& select(a, result) == v &*& b <= result &*& result < e;
{
   switch(l) {
     case O: {
      open array_multiset(b, e, a, m);
      assert false;
     }
     case S(p): {
        if (select(a, b) == v) {
          return b;
        } else {
          open array_multiset(b, e, a, m);
          int res = array_multiset_assoc(a, b+1, e, v, p);
          close array_multiset(b, e, a, m);
          return res;
        }
     }
   }
}

lemma void array_multiset_select(array(int, int) a, int b, int e, int i, nat l)
requires b <= i &*& i < e &*& array_multiset(b, e, a, ?m) &*& int_diff(b, e, l) == true;
ensures multiset_select(m, select(a, i)) != O &*& array_multiset(b, e, a, m);
{
   switch(l)
   {
      case O: { 
        open int_diff(b, e, l);
        assert false;
      }
      case S(p): {
        if (b == i) {
           open array_multiset(b, e, a, m);
        } else {
           open array_multiset(b, e, a, m);
           array_multiset_select(a, b+1, e, i, p);
        }
      }
   }
}

lemma int same_multiset_assoc(array(int, int) start, array(int, int) end, int b, int e, int i)
  requires same_multiset(start, end, b, e) &*& b <= i &*& i < e;
  ensures same_multiset(start, end, b, e) &*& select(start, i) == select(end, result) &*& b <= result &*& result < e;
{
   open same_multiset(start, end, b, e);
   nat l = int_diff_always(b, e);
   array_multiset_select(start, b, e, i, l);
   int j = array_multiset_assoc(end, b, e, select(start, i), l);
   close same_multiset(start, end, b, e);
   return j;
}
