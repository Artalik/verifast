#ifndef MAPPING_H
#define MAPPING_H

#include "intdiff.gh"

/*
   Axiomatic theory of mappings.

   The theory of mappings provides a built-in type mapping(t, u) of possibly infinite mappings indexed by t and ranging over u.
   The primitive functions are: select, store, constant_mapping, and mapping_ext.

   When using Z3, these functions are directly mapped to their conterpart in the so-called array-theory.
*/

fixpoint u select<t,u> (mapping(t,u) mp, t x);
fixpoint mapping(t, u) store<t, u> (mapping(t, u) mp, t x, u y);
fixpoint mapping(t, u) constant_mapping<t,u> (u v);
fixpoint t mapping_ext<t, u> (mapping(t, u) a, mapping(t, u) b);

lemma void constant_select<t,u> (u v, t i)
  requires true;
  ensures select (constant_mapping<t,u>(v), i) == v;
{}

lemma void select_store<t,u> (mapping(t,u) mp, t x, u y, t z)
    requires true;
    ensures select (store(mp, x, y), z) == ((x == z) ? y : select (mp, z));
{}

lemma void mapping_extensionality<t, u>(mapping(t, u) a, mapping(t, u) b)
requires select(a, mapping_ext<t, u>(a, b)) == select(b, mapping_ext<t, u>(a, b));
ensures a == b;
{assume(false);}

fixpoint bool same_mapping<a> (mapping(int, a) mp1, mapping(int, a) mp2, int b, nat n) {
  switch(n) {
    case zero: return true;
    case succ(pred): return select(mp1, b) == select(mp2, b) && same_mapping(mp1, mp2, b+1, pred);
  }
}

predicate mapping_model (int* a, int b, int e, mapping(int,int) mp) =
  (b >= e) ? true : (integer(a+b,?v) &*& select(mp, b) == v &*& mapping_model(a, b+1, e, mp));

lemma void empty_mapping(int* a, int i, mapping(int, int) mp)
requires true;
ensures mapping_model(a, i, i, mp);
{
  close mapping_model(a, i, i, mp);
}

lemma void mapping_model_out_of_range_diff(int* a, int b, int e, mapping(int,int) mp, int i, int v, nat n)
  requires (i < b || i >= e) &*& mapping_model(a, b, e, mp) &*& int_diff(b, e, n) == true;
  ensures mapping_model(a, b, e, store(mp, i, v));
{ switch (n) {
    case zero : {
      open mapping_model(a, b, e, mp);
      close mapping_model(a, b, e, store(mp, i, v));
    }
    case succ(p) : {
      open mapping_model(a, b, e, mp);
      mapping_model_out_of_range_diff(a, b+1, e, mp, i, v, p);
      close mapping_model(a, b, e, store(mp, i, v));
    }
  }
}

lemma void mapping_model_out_of_range(int* a, int b, int e, mapping(int,int) mp, int i, int v)
  requires (i < b || i >= e) &*& mapping_model(a, b, e, mp) &*& b <= e;
  ensures mapping_model(a, b, e, store(mp, i, v));
{
  nat n = int_diff_make(b, e);
  mapping_model_out_of_range_diff(a, b, e, mp, i, v, n);
}

lemma void close_mapping_model_right(nat n)
requires mapping_model(?a, ?b, ?e, ?mp) &*& b <= e &*& int_diff(b, e, n) == true &*& a[e] |-> select(mp, e);
ensures mapping_model(a, b, e+1, mp);
{
  switch(n) {
    case zero: {
      open mapping_model(a, b, e, mp);
      assert (b == e);
      close mapping_model(a, e+1, e+1, mp);
      close mapping_model(a, b, e+1, mp);
    }
    case succ(p): {
      open mapping_model(a, b, e, mp);
      close_mapping_model_right(p);
      close mapping_model(a, b, e+1, mp);
    }
  }
}

lemma void open_mapping_model_right(int* a, int b, int e, mapping(int, int) mp, nat n)
requires mapping_model(a, b, e+1, mp) &*& b <= e &*& int_diff(b, e, n) == true;
ensures mapping_model(a, b, e, mp) &*& a[e] |-> select(mp, e);
{
  switch(n) {
    case zero: {
      open mapping_model(a, b, e+1, mp);
      open mapping_model(a, b+1, e+1, mp);
      close mapping_model(a, b, e, mp);
    }
    case succ(p): {
      open mapping_model(a, b, e+1, mp);
      open_mapping_model_right(a, b+1, e, mp, p);
      close mapping_model(a, b, e, mp);
    }
  }
}

lemma void mapping_model_init_diff(int* a, int length, nat n)
requires ints((void*)a, length, _) &*& length >= 0 &*& int_diff(0, length, n) == true;
ensures mapping_model(a, 0, length, _);
{
   switch (n) {
     case zero: {
     	empty_mapping(a,0,constant_mapping<int,int>(0));
     }
     case succ(p): {
     	open_ints_right(p);
     	int_diff_translate(1,length,-1,p);
     	mapping_model_init_diff(a,length-1,p);
     	assert a[length-1] |-> ?v;
     	assert mapping_model(a, 0, length-1, ?mp);
        mapping_model_out_of_range(a, 0, length-1, mp, length-1, v);
     	close_mapping_model_right(p);
     	int_diff_translate(0,length-1,1,p);
     }
  }
}

lemma void mapping_model_init(int* a, int length)
requires ints((void*)a, length, _) &*& length >= 0;
ensures mapping_model(a, 0, length, _);
{
  int_diff_nat_of_int(0, length);
  mapping_model_init_diff(a, length, nat_of_int(length));
}

lemma void mapping_model_delete(int* a, int length, nat len)
requires mapping_model(a, 0, length, ?mp) &*& length >= 0 &*& int_diff(0, length, len) == true;
ensures ints((void*)a, length, _);
{
   switch(len) {
     case zero: {
       open mapping_model(a, 0, length, mp);
       close ints((void*)a, 0, nil);
     }
     case succ(p): {
       int_diff_translate(1, length, -1, p);
       open_mapping_model_right(a, 0, length-1, mp, p);
       mapping_model_delete(a, length-1, p);
       close_ints_right(p);
     }
   }
}

lemma void mapping_model_select_unfold_diff(int* a, int b, int e, mapping(int,int) mp, int i, nat n)
requires mapping_model(a, b, e, mp) &*& b <= i &*& i < e &*& int_diff(b, i+1, n) == true;
ensures mapping_model(a, b, i, mp) &*& a[i] |-> select(mp, i) &*& mapping_model(a, i+1, e, mp);
{
  switch (n) {
    case zero : {
       open int_diff(b,i+1,n);
    }
    case succ(p) : {
      open mapping_model(a, b, e, mp);
      if (b+1 <= i) {
        mapping_model_select_unfold_diff(a, b+1, e, mp, i, p);
      }
      close mapping_model(a, b, i, mp);
    }
  }
}

lemma void mapping_model_select_unfold(int* a, int b, int e, mapping(int,int) mp, int i)
requires mapping_model(a, b, e, mp) &*& b <= i &*& i < e;
ensures mapping_model(a, b, i, mp) &*& a[i] |-> select(mp, i) &*& mapping_model(a, i+1, e, mp);
{
  int_diff_nat_of_int(b, i+1);
  mapping_model_select_unfold_diff(a, b, e, mp, i, nat_of_int(i+1-b));
}

lemma void mapping_model_store_fold_diff(int* a, int b, int e, mapping(int,int) mp, int i, nat n)
requires mapping_model(a, b, i, mp) &*& a[i] |-> ?v &*& mapping_model(a, i+1, e, mp) &*& b <= i &*& i < e &*& int_diff(b, i+1, n) == true;
ensures mapping_model(a, b, e, store(mp, i, v));
{
  switch (n) {
    case zero : {}
    case succ(p) : {
      open mapping_model(a, b, i, mp);
      if (b < i){
        mapping_model_store_fold_diff(a, b+1, e, mp, i, p);
        close mapping_model(a, b, e, store(mp, i, v));
      }else{
        mapping_model_out_of_range(a, b+1, e, mp, i, v);
        close mapping_model(a, b, e, store(mp, i, v));
      }
    }
  }
}

lemma void mapping_model_store_fold(int* a, int b, int e, mapping(int,int) mp, int i)
requires mapping_model(a, b, i, mp) &*& a[i] |-> ?v &*& mapping_model(a, i+1, e, mp) &*& b <= i &*& i < e;
ensures mapping_model(a, b, e, store(mp, i, v));
{
  int_diff_nat_of_int(b, i+1);
  mapping_model_store_fold_diff(a, b, e, mp, i, nat_of_int(i+1-b));
}

lemma void mapping_model_select_fold(int* a, int b, int e, mapping(int,int) mp, int i)
requires mapping_model(a, b, i, mp) &*& a[i] |-> select(mp, i) &*& mapping_model(a, i+1, e, mp) &*& b <= i &*& i < e;
ensures mapping_model(a, b, e, mp);
{
   mapping_model_store_fold(a, b, e, mp, i);
}


fixpoint bool mapping_forall<a>(mapping(int, a) mp, fixpoint(a, bool) p, int b, nat n) {
  switch(n) {
    case zero: return true;
    case succ(pred): return (p(select(mp, b)) && mapping_forall(mp, p, b+1, pred));
  }
}

lemma void mapping_forall_store<a> (mapping(int, a) mp, fixpoint(a, bool) p, int b, nat n, int i, a v)
requires mapping_forall(mp, p, b, n) == true;
ensures mapping_forall(store(mp, i, v), p, b, n) == (i < b ? true : i >= b + int_of_nat(n) ? true : p(v));
{
  switch(n) {
    case zero:
    case succ(pred): mapping_forall_store(mp, p, b+1, pred, i, v);
  }
}

lemma void mapping_forall_close_right<a> (mapping(int, a) mp, fixpoint(a, bool) p, int b, int e, nat n)
requires mapping_forall(mp, p, b, n) == true &*& p(select(mp, e)) == true &*& b <= e &*& int_diff(b, e, n) == true;
ensures mapping_forall(mp, p, b, succ(n)) == true;
{
  switch(n) {
    case zero:
    case succ(pred): mapping_forall_close_right(mp, p, b+1, e, pred);
  }

}

lemma void mapping_forall_in<a>(mapping(int, a) mp, fixpoint(a, bool) p, int b, int e, nat n, int i)
requires mapping_forall(mp, p, b, n) == true &*& b <= i &*& i < e &*& int_diff(b, e, n) == true;
ensures p(select(mp, i)) == true;
{
  switch(n) {
    case zero: assert false;
    case succ(pred): {
      if (b != i) mapping_forall_in(mp, p, b+1, e, pred, i);
    }
  }
}
lemma void same_mapping_refl<a>(mapping(int, a) mp, int b, nat n)
requires true;
ensures same_mapping(mp, mp, b, n) == true;
{
  switch(n) {
    case zero:
    case succ(pred): same_mapping_refl(mp, b+1, pred);
  }
}

lemma void same_mapping_sym<a>(mapping(int, a) mp1, mapping(int, a) mp2, int b, nat n)
requires same_mapping(mp1, mp2, b, n) == true;
ensures same_mapping(mp2, mp1, b, n) == true;
{
  switch(n) {
    case zero:
    case succ(pred): same_mapping_sym(mp1, mp2, b+1, pred);
  }
}

lemma void same_mapping_trans<a>(mapping(int, a) mp1, mapping(int, a) mp2, mapping(int, a) mp3, int b, nat n)
requires same_mapping(mp1, mp2, b, n) == true &*& same_mapping(mp2, mp3, b, n) == true;
ensures same_mapping(mp1, mp3, b, n) == true;
{
  switch(n) {
    case zero:
    case succ(pred): same_mapping_trans(mp1, mp2, mp3, b+1, pred);
  }
}

lemma void same_mapping_out<a>(mapping(int, a) mp, int b, int e, nat n, int i, a v)
requires int_diff(b, e, n) == true &*& b <= e &*& (i < b || e <= i);
ensures same_mapping(mp, store(mp, i, v), b, n) == true;
{
  switch(n) {
    case zero:
    case succ(pred): same_mapping_out(mp, b+1, e, pred, i, v);
  }
}

lemma mapping(int, int) mapping_model_concat(int* a, mapping(int, int) mp1, mapping(int, int) mp2, int b, nat n, int p, int e)
requires mapping_model(a, b, p, mp1) &*& mapping_model(a, p, e, mp2) &*& int_diff(b, p, n) == true &*& b <= p &*& p <= e;
ensures mapping_model(a, b, e, result) &*& same_mapping(mp1, result, b, n) == true &*& same_mapping(mp2, result, p, nat_of_int(e-p)) == true;
{
  switch(n) {
    case zero: {
      open mapping_model(a, b, p, mp1);
      same_mapping_refl(mp2, p, nat_of_int(e-p));
      return mp2;
    }
    case succ(pred): {
      open mapping_model(a, b, p, mp1);
      mapping(int, int) mp = mapping_model_concat(a, mp1, mp2, b+1, pred, p, e);
      mapping(int, int) res = store(mp, b, select(mp1, b));
      mapping_model_out_of_range(a, b+1, e, mp, b, select(mp1, b));
      close mapping_model(a, b, e, res);
      int_diff_nat_of_int(b+1, p);
      same_mapping_out(mp, b+1, p, pred, b, select(mp1, b));
      same_mapping_trans(mp1, mp, res, b+1, pred);
      int_diff_nat_of_int(p, e);
      same_mapping_out(mp, p, e, nat_of_int(e-p), b, select(mp1, b));
      same_mapping_trans(mp2, mp, res, p, nat_of_int(e-p));
      return res;
    }
  }
}

#endif
