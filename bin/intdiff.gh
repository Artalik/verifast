inductive nat = O | S(nat);

fixpoint bool int_diff(int b, int e, nat n) {
  switch (n) {
    case O: return (b >= e);
    case S(p): return (b < e && int_diff(b+1, e, p));
}}

lemma nat int_diff_always(int b, int e)
requires true;
ensures int_diff(b, e, result) == true;
{
  if (b >= e) {
    return O;
  } else {
    int i = e;
    nat l = O;
    for (; i > b; i--)
    invariant b <= i &*& i <= e &*& int_diff(i, e, l) == true;
    decreases i - b;
    {
       l = S(l);
    }
    return l;
  }
}

lemma void int_diff_translate(int b, int e, int delta, nat l)
requires int_diff(b, e, l) == true;
ensures int_diff(b+delta, e+delta, l) == true;
{
  switch(l) {
    case O: {}
    case S(p): int_diff_translate(b+1, e, delta, p);
  }
}


lemma void open_ints_right(nat n)
requires ints(?p, ?count, ?vs) &*& int_diff(0, count, S(n)) == true;
ensures ints(p, count-1, ?bl) &*& integer(p+count-1, ?lst) &*& vs == append(bl, cons(lst, nil));
{
  switch(n) {
    case O: {
      open ints(p, count, vs);
      open ints(p+1, count-1, _);
      close ints(p, count-1, nil);
    }
    case S(m): {
      int_diff_translate(1, count, -1, n);
      open ints(p, count, vs);
      assert ints(p+1, count-1, ?l);
      open_ints_right(m);
      close ints(p, count-1, _);
    }
  }
}