inductive nat = O | S(nat);


predicate int_diff(int b, int e; nat length) =
  b >= e ? length == O : (int_diff(b+1, e, ?pred) &*& length == S(pred));

lemma void int_diff_always(int b, int e)
requires true;
ensures int_diff(b, e, _);
{
  if (b >= e) {
    close int_diff(b, e, O);
  } else {
    int i = e;
    close int_diff(e, e, O);
    for (; i > b; i--)
    invariant b <= i &*& i <= e &*& int_diff(i, e, ?l);
    decreases i - b;
    {
       close int_diff(i-1, e, S(l));
    }
  }
}


lemma void int_diff_clear(int b, int e, nat l)
requires int_diff(b, e, l);
ensures true;
{
  open int_diff(b, e, l);
  switch(l) {
    case O:
    case S(p): int_diff_clear(b+1, e, p);
  }
}

lemma void int_diff_translate(int b, int e, int delta, nat l)
requires int_diff(b, e, l);
ensures int_diff(b+delta, e+delta, l);
{
  switch(l) {
    case O: {
      open int_diff(b, e, l);
      close int_diff(b+delta, e+delta, l);
    }
    case S(p): {
      open int_diff(b, e, l);
      int_diff_translate(b+1, e, delta, p);
      close int_diff(b+delta, e+delta, l);
    }
  }
}


lemma void open_ints_right(nat n)
requires ints(?p, ?count, ?vs) &*& int_diff(0, count, S(n)); 
ensures ints(p, count-1, ?bl) &*& integer(p+count-1, ?lst) &*& vs == append(bl, cons(lst, nil)) &*& int_diff(0, count, S(n));
{
  switch(n) {
    case O: {
      open int_diff(0, count, S(n));
      open int_diff(1, count, n);
      open ints(p, count, vs);
      open ints(p+1, count-1, _);
      close ints(p, count-1, nil);
    }
    case S(m): {
      open int_diff(0, count, S(n));
      int_diff_translate(1, count, -1, n);
      open ints(p, count, vs);
      assert ints(p+1, count-1, ?l);
      open_ints_right(m);
      close ints(p, count-1, _);
      int_diff_translate(0, count-1, 1, n);
      close int_diff(0, count, S(n));
    }
  }
}