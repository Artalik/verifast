#ifndef INTDIFF_H
#define INTDIFF_H

#include "nat.gh"

fixpoint bool int_diff(int b, int e, nat n) {
  switch (n) {
    case zero: return (b >= e);
    case succ(p): return (b < e && int_diff(b+1, e, p));
}}

lemma nat int_diff_always(int b, int e)
requires true;
ensures int_diff(b, e, result) == true;
{
  if (b >= e) {
    return zero;
  } else {
    int i = e;
    nat l = zero;
    for (; i > b; i--)
    invariant b <= i &*& i <= e &*& int_diff(i, e, l) == true;
    decreases i - b;
    {
       l = succ(l);
    }
    return l;
  }
}

lemma void int_diff_translate(int b, int e, int delta, nat l)
requires int_diff(b, e, l) == true;
ensures int_diff(b+delta, e+delta, l) == true;
{
  switch(l) {
    case zero: {}
    case succ(p): int_diff_translate(b+1, e, delta, p);
  }
}


lemma void open_ints_right(nat n)
requires ints(?p, ?count, ?vs) &*& int_diff(0, count, succ(n)) == true;
ensures ints(p, count-1, ?bl) &*& integer(p+count-1, ?lst) &*& vs == append(bl, cons(lst, nil));
{
  switch(n) {
    case zero: {
      open ints(p, count, vs);
      open ints(p+1, count-1, _);
      close ints(p, count-1, nil);
    }
    case succ(m): {
      int_diff_translate(1, count, -1, n);
      open ints(p, count, vs);
      assert ints(p+1, count-1, ?l);
      open_ints_right(m);
      close ints(p, count-1, _);
    }
  }
}

lemma void close_ints_right(nat n)
requires ints(?a, ?count, ?vs) &*& int_diff(0, count, succ(n)) == true &*& integer(a+count, ?lst); 
ensures ints(a, count+1, ?bl)  &*& bl == append(vs, cons(lst, nil));
{
  switch (n) {
    case zero : {
      open ints(a, count, vs);
      open ints(a+1, count-1, _);
    }
    case succ(p) : {
      int_diff_translate(1, count, -1, n);
      open ints(a, count, vs);
      close_ints_right(p);
    }
  }
}